/*
 Navicat Premium Data Transfer

 Source Server         : aliyun
 Source Server Type    : MySQL
 Source Server Version : 50734
 Source Host           : 39.101.191.240:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50734
 File Encoding         : 65001

 Date: 31/08/2021 19:34:29
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_attach
-- ----------------------------
DROP TABLE IF EXISTS `t_attach`;
CREATE TABLE `t_attach`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `fname` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `ftype` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `fkey` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `author_id` int(10) NULL DEFAULT NULL,
  `created` int(10) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_attach
-- ----------------------------

-- ----------------------------
-- Table structure for t_comments
-- ----------------------------
DROP TABLE IF EXISTS `t_comments`;
CREATE TABLE `t_comments`  (
  `coid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `cid` int(10) UNSIGNED NULL DEFAULT 0,
  `created` int(10) UNSIGNED NULL DEFAULT 0,
  `author` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `author_id` int(10) UNSIGNED NULL DEFAULT 0,
  `owner_id` int(10) UNSIGNED NULL DEFAULT 0,
  `mail` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `ip` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `agent` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `type` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 'comment',
  `status` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 'approved',
  `parent` int(10) UNSIGNED NULL DEFAULT 0,
  PRIMARY KEY (`coid`) USING BTREE,
  INDEX `cid`(`cid`) USING BTREE,
  INDEX `created`(`created`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comments
-- ----------------------------

-- ----------------------------
-- Table structure for t_contents
-- ----------------------------
DROP TABLE IF EXISTS `t_contents`;
CREATE TABLE `t_contents`  (
  `cid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `slug` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `created` int(10) UNSIGNED NULL DEFAULT 0,
  `modified` int(10) UNSIGNED NULL DEFAULT 0,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容文字',
  `author_id` int(10) UNSIGNED NULL DEFAULT 0,
  `type` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 'post',
  `status` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 'publish',
  `tags` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `categories` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `hits` int(10) UNSIGNED NULL DEFAULT 0,
  `comments_num` int(10) UNSIGNED NULL DEFAULT 0,
  `allow_comment` tinyint(1) NULL DEFAULT 1,
  `allow_ping` tinyint(1) NULL DEFAULT 1,
  `allow_feed` tinyint(1) NULL DEFAULT 1,
  PRIMARY KEY (`cid`) USING BTREE,
  UNIQUE INDEX `slug`(`slug`) USING BTREE,
  INDEX `created`(`created`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_contents
-- ----------------------------
INSERT INTO `t_contents` VALUES (1, 'about my blog', 'about', 1619300000, 1620535535, '## Blog\r\n\r\n[Blog](https://github.com/zz201507/My-blog)  fork from [My Blog](https://github.com/ZHENFENG13/My-Blog) , 该作者是在 [Tale](https://github.com/otale/tale) 博客系统基础上进行修改的。\r\n\r\n`Tale` 使用了轻量级 mvc 框架 `Blade` 开发，默认主题使用了漂亮的 `pinghsu` 。\r\n\r\n`My-Blog` 使用的是 Docker + SpringBoot + Mybatis + thymeleaf 打造的一个个人博客模板。\r\n\r\n***\r\n\r\n[Blog](https://github.com/zz201507/My-blog)  在  [My Blog](https://github.com/ZHENFENG13/My-Blog)  的基础上去除了 Docker，采用的是 SpringBoot + Mybatis + thymeleaf  + MySQL 搭建的一个博客，其中在原来作者的基础上优化了。\r\n\r\n## 开源协议\r\n\r\n[MIT](./LICENSE)\r\n\r\n## 感谢\r\n\r\n[ZHENFENG13](https://github.com/ZHENFENG13)\r\n\r\n[otale](https://github.com/otale)\r\n', 1, 'page', 'publish', NULL, NULL, 354, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (3, '《Java 多线程编程核心技术》学习笔记及总结', 'Java-Thread', 1619400000, 1497323171, '## 第一章 —— Java 多线程技能\r\n\r\n线程技术点：\r\n\r\n+ 线程的启动\r\n+ 如何使线程暂停\r\n+ 如何使线程停止\r\n+ 线程的优先级\r\n+ 线程安全相关问题\r\n<!-- more -->\r\n### 进程和线程的概念及多线程的优点\r\n\r\n进程：比如我们电脑运行的 QQ.exe 程序，是操作系统管理的基本运行单元\r\n\r\n线程：在进程中独立运行的子任务，比如 QQ.exe 进程中就有很多线程在运行，下载文件线程、发送消息线程、语音线程、视频线程等。\r\n\r\n多线程优点：我们电脑可以同时操作不同的软件，边听着歌，敲着代码，查看 pdf 文档，浏览网页等，CPU 在这些任务之间不停的切换，切换非常快，所以我们就觉得他们是在同时运行的。\r\n\r\n### 使用多线程\r\n\r\n#### 继承 Thread 类\r\n\r\nJDK 源码注释（Thread.java）如下：\r\n\r\n```java\r\nOne is to declare a class to be a subclass(子类) of <code>Thread</code>. This subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be allocated and started. For example, a thread that computes primes\r\nlarger than a stated value could be written as follows:\r\n//继承 Thread 类\r\nclass PrimeThread extends Thread {\r\n         long minPrime;\r\n         PrimeThread(long minPrime) {\r\n          this.minPrime = minPrime;\r\n         }\r\n\r\n         public void run() {\r\n             // compute primes larger than minPrime\r\n             重写 Thread 类的 run 方法\r\n          }\r\n     }\r\n\r\nThe following code would then create a thread and start it running:\r\n//开启线程\r\n    PrimeThread p = new PrimeThread(143);\r\n    p.start();\r\n```\r\n\r\n#### 实现 Runnable 接口\r\n\r\nJDK 源码注释（Thread.java）如下：\r\n\r\n```java\r\nThe other way to create a thread is to declare a class that implements the <code>Runnable</code> interface. That class then implements the <code>run</code> method. An instance of the class can then be allocated, passed as an argument when creating\r\n<code>Thread</code>, and started. The same example in this other style looks like the following:\r\n//实现 Runnable 接口\r\n    class PrimeRun implements Runnable {\r\n        long minPrime;\r\n        PrimeRun(long minPrime) {\r\n            this.minPrime = minPrime;\r\n         }\r\n\r\n         public void run() {\r\n            // compute primes larger than minPrime\r\n            //重写 run 方法\r\n        }\r\n    }\r\n\r\nThe following code would then create a thread and start it running:\r\n//开启线程\r\n     PrimeRun p = new PrimeRun(143);\r\n     new Thread(p).start();\r\n```\r\n\r\n\r\n\r\n### currentThread() 方法\r\n\r\n该方法返回代码段正在被哪个线程调用的信息。\r\n\r\n### isAlive() 方法\r\n\r\n判断当前线程是否处于活动状态（已经启动但未终止）\r\n\r\n### sleep() 方法\r\n\r\n在指定的毫秒数内让当前“正在执行的线程（this.currentThread() 返回的线程）”休眠（暂停执行）。\r\n\r\n### getId() 方法\r\n\r\n获取线程的唯一标识\r\n\r\n### 停止线程\r\n\r\n可以使用 <del>Thread.stop()</del> 方法，但最好不要用，因为这个方法是不安全的，已经弃用作废了。\r\n\r\n大多数停止一个线程是使用 Thread.interrupt() 方法\r\n\r\n#### 判断线程是否是停止状态\r\n\r\n+    interrupted()\r\n```java\r\n     //测试当前线程是否已经中断了，这个线程的中断状态会被这个方法清除。\r\n     //换句话说，如果连续两次调用了这个方法，第二次调用的时候将会返回 false ，\r\n     public static boolean interrupted() {\r\n             return currentThread().isInterrupted(true);\r\n     }\r\n```\r\n\r\n+    isInterrupted()\r\n\r\n```java\r\n        //测试线程是否已经中断了，线程的状态不会受这个方法的影响\r\n        //线程中断被忽略，因为线程处于中断下不处于活动状态的线程由此返回false的方法反映出来\r\n         public boolean isInterrupted() {\r\n                return isInterrupted(false);\r\n        }\r\n        /**\r\n     * Tests if some Thread has been interrupted.  The interrupted state\r\n     * is reset or not based on the value of ClearInterrupted that is\r\n     * passed.\r\n     */\r\n     private native boolean isInterrupted(boolean ClearInterrupted);\r\n```\r\n\r\n#### 在沉睡中停止\r\n\r\n```java\r\npublic class MyThread2 extends Thread\r\n{\r\n    @Override\r\n    public void run() {\r\n        try {\r\n            System.out.println(\"run start\");\r\n            Thread.sleep(20000);\r\n            System.out.println(\"run end\");\r\n        } catch (InterruptedException e) {\r\n            System.out.println(\"run catch \"+this.isInterrupted());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n        try {\r\n            MyThread2 t2 = new MyThread2();\r\n            t2.start();\r\n            Thread.sleep(200);\r\n            t2.interrupt();\r\n        } catch (InterruptedException e) {\r\n            System.out.println(\"main catch\");\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"main end\");\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n```java\r\nrun start\r\nmain end\r\nrun catch false\r\njava.lang.InterruptedException: sleep interrupted\r\n	at java.lang.Thread.sleep(Native Method)\r\n	at com.zhisheng.thread.thread1.MyThread2.run(MyThread2.java:12)\r\n```\r\n\r\n从运行结果来看，如果在 sleep 状态下停止某一线程，会进入 catch 语句，并清除停止状态值，使之变成 false。\r\n\r\n#### 在停止中沉睡\r\n\r\n```java\r\npublic class MyThread3 extends Thread\r\n{\r\n    @Override\r\n    public void run() {\r\n        try {\r\n            System.out.println(\"run start\");\r\n            Thread.sleep(20000);\r\n            System.out.println(\"run end\");\r\n        } catch (InterruptedException e) {\r\n            System.out.println(\"run catch \"+this.isInterrupted());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n            MyThread3 t3 = new MyThread3();\r\n            t3.start();\r\n            t3.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n```java\r\nrun start\r\nrun catch false\r\njava.lang.InterruptedException: sleep interrupted\r\n	at java.lang.Thread.sleep(Native Method)\r\n	at com.zhisheng.thread.thread1.MyThread3.run(MyThread3.java:12)\r\n```\r\n\r\n#### 能停止的线程 —— 暴力停止\r\n\r\n使用 stop() 方法停止线程\r\n\r\n### 暂停线程\r\n\r\n可使用 suspend 方法暂停线程，使用 resume() 方法恢复线程的执行。\r\n\r\n#### suspend 和 resume 方法的使用\r\n\r\n```java\r\npublic class MyThread4 extends Thread\r\n{\r\n    private int i;\r\n    public int getI() {\r\n        return i;\r\n    }\r\n    public void setI(int i) {\r\n        this.i = i;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            i++;\r\n        }\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        MyThread4 t4 = new MyThread4();\r\n        t4.start();\r\n        System.out.println(\"A----- \" + System.currentTimeMillis() + \" ---- \" + t4.getI());\r\n        Thread.sleep(2000);\r\n        System.out.println(\"A----- \" + System.currentTimeMillis() + \" ---- \" + t4.getI());\r\n        t4.suspend();\r\n        Thread.sleep(2000);\r\n        t4.resume();\r\n        System.out.println(\"B----- \" + System.currentTimeMillis() + \" ---- \" + t4.getI());\r\n        Thread.sleep(2000);\r\n        System.out.println(\"B----- \" + System.currentTimeMillis() + \" ---- \" + t4.getI());\r\n    }\r\n}\r\n```\r\n\r\n从运行结果来看，线程的确能够暂停和恢复。\r\n\r\n但是 suspend 和 resume 方法的缺点就是：**不同步**，因为线程的暂停导致数据的不同步。\r\n\r\n### yield 方法\r\n\r\n```java\r\n/**\r\n     * A hint to the scheduler that the current thread is willing to yield\r\n     * its current use of a processor. The scheduler is free to ignore this\r\n     * hint.\r\n     *\r\n     * <p> Yield is a heuristic attempt to improve relative progression\r\n     * between threads that would otherwise over-utilise a CPU. Its use\r\n     * should be combined with detailed profiling and benchmarking to\r\n     * ensure that it actually has the desired effect.\r\n     *\r\n     * <p> It is rarely appropriate to use this method. It may be useful\r\n     * for debugging or testing purposes, where it may help to reproduce\r\n     * bugs due to race conditions. It may also be useful when designing\r\n     * concurrency control constructs such as the ones in the\r\n     * {@link java.util.concurrent.locks} package.\r\n     */\r\n    //暂停当前正在执行的线程对象，并执行其他线程。暂停的时间不确定。\r\n    public static native void yield();\r\n```\r\n\r\n```java\r\npublic class MyThread5 extends Thread\r\n{\r\n    @Override\r\n    public void run() {\r\n        double start = System.currentTimeMillis();\r\n        for (int i = 0; i < 200000; i++) {\r\n            //yield();//暂停的时间不确定\r\n            i++;\r\n        }\r\n        double end = System.currentTimeMillis();\r\n        System.out.println(\"time is \"+(end - start));\r\n    }\r\n    public static void main(String[] args) {\r\n        MyThread5  t5 = new MyThread5();\r\n        t5.start();\r\n    }\r\n}\r\n```\r\n\r\n### 线程的优先级\r\n\r\n设置优先级的方法：setPriority() 方法\r\n\r\n```java\r\npublic final void setPriority(int newPriority) {\r\n        ThreadGroup g;\r\n        checkAccess();\r\n        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        if((g = getThreadGroup()) != null) {\r\n            if (newPriority > g.getMaxPriority()) {\r\n                newPriority = g.getMaxPriority();\r\n            }\r\n            setPriority0(priority = newPriority);\r\n        }\r\n    }\r\n```\r\n\r\n不一定优先级高的线程就先执行。\r\n\r\n### 守护线程\r\n\r\n当进程中不存在非守护线程了，则守护线程自动销毁。垃圾回收线程就是典型的守护线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。\r\n\r\n```java\r\n /**\r\n     * Marks this thread as either a {@linkplain #isDaemon daemon} thread\r\n     * or a user thread. The Java Virtual Machine exits when the only\r\n     * threads running are all daemon threads.\r\n     *\r\n     * <p> This method must be invoked before the thread is started.\r\n     *\r\n     * @param  on\r\n     *         if {@code true}, marks this thread as a daemon thread\r\n     * @throws  IllegalThreadStateException\r\n     *          if this thread is {@linkplain #isAlive alive}\r\n     * @throws  SecurityException\r\n     *          if {@link #checkAccess} determines that the current\r\n     *          thread cannot modify this thread\r\n     */\r\n    public final void setDaemon(boolean on) {\r\n        checkAccess();\r\n        if (isAlive()) {\r\n            throw new IllegalThreadStateException();\r\n        }\r\n        daemon = on;\r\n    }\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 第二章 —— 对象及变量的并发访问\r\n\r\n技术点：\r\n\r\n+ synchronized 对象监视器为 Object 时的使用\r\n+ synchronized 对象监视器为 Class 时的使用\r\n+ 非线程安全是如何出现的\r\n+ 关键字 volatile 的主要作用\r\n+ 关键字 volatile 与 synchronized 的区别及使用情况\r\n\r\n### synchronized 同步方法\r\n\r\n#### 方法内的变量为线程安全\r\n\r\n“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”了。\r\n\r\n#### 实例变量非线程安全\r\n\r\n如果多线程共同访问一个对象中的实例变量，则有可能出现“非线程安全”问题。\r\n\r\n在两个线程访问同一个对象中的同步方法时一定是线程安全的。\r\n\r\n#### 脏读\r\n\r\n发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。\r\n\r\n如下例子就可以说明，如果不加 synchronized 关键字在 setValue 和 getValue 方法上，就会出现数据脏读。\r\n\r\n```java\r\nclass VarName\r\n{\r\n    private String userName = \"A\";\r\n    private String password = \"AA\";\r\n    synchronized public void setValue(String userName, String password) {\r\n        try {\r\n            this.userName = userName;\r\n            Thread.sleep(500);\r\n            this.password = password;\r\n            System.out.println(\"setValue method Thread name is :  \" + Thread.currentThread().getName() + \" userName = \" + userName + \" password = \" + password);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    //synchronized\r\n    public void getValue() {\r\n        System.out.println(\"getValue method Thread name is :  \" + Thread.currentThread().getName() + \" userName = \" + userName + \" password = \" + password);\r\n    }\r\n}\r\n\r\nclass Thread1 extends Thread\r\n{\r\n    private VarName varName;\r\n    public Thread1(VarName varName) {\r\n        this.varName = varName;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        varName.setValue(\"B\", \"BB\");\r\n    }\r\n}\r\n\r\npublic class Test\r\n{\r\n    public static void main(String[] args) throws InterruptedException {\r\n        VarName v = new VarName();\r\n        Thread1 thread1 = new Thread1(v);\r\n        thread1.start();\r\n        Thread.sleep(200);//打印结果受睡眠时间的影响\r\n        v.getValue();\r\n    }\r\n}\r\n```\r\n\r\n#### synchronized 锁重入\r\n\r\n关键字 synchronized 拥有锁重入的功能，也就是在使用 synchronized 时，当一个线程得到一个对象锁后，再次请求此对象锁是可以再次得到该对象的锁的。这也证明了在一个 synchronized 方法/块的内部调用本类的其他 synchronized 方法/块时，是永远可以得到锁的。\r\n\r\n```java\r\nclass Service\r\n{\r\n    synchronized public void service1() {\r\n        System.out.println(\"service 1\");\r\n        service2();\r\n    }\r\n    synchronized public void service2() {\r\n        System.out.println(\"service 2\");\r\n        service3();\r\n    }\r\n    synchronized public void service3() {\r\n        System.out.println(\"service 3\");\r\n    }\r\n}\r\n\r\nclass Thread2 extends Thread\r\n{\r\n    @Override\r\n    public void run() {\r\n        Service s = new Service();\r\n        s.service1();\r\n    }\r\n}\r\n\r\npublic class Test2\r\n{\r\n    public static void main(String[] args) {\r\n        Thread2 t2 = new Thread2();\r\n        t2.start();\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n```\r\nservice 1\r\nservice 2\r\nservice 3\r\n```\r\n\r\n#### 同步不具有继承性\r\n\r\n同步不可以继承。\r\n\r\n### synchronized 同步语句块\r\n\r\n#### synchronized 代码块间的同步性\r\n\r\n当一个线程访问 object 的一个 synchronized(this) 同步代码块时，其他线程对同一个 object 中所有其他 synchronized(this) 同步代码块的访问将被阻塞，这说明 synchronized 使用的 “对象监视器” 是一个。\r\n\r\n#### 将任意对象作为对象监视器\r\n\r\n多个线程调用同一个对象中的不同名称的 synchronized 同步方法或者 synchronized(this) 同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。\r\n\r\n#### 静态同步 synchronized 方法与  synchronized(class) 代码块\r\n\r\n关键字 synchronized 还可以应用在 static 静态方法上，如果这样写就是对当前的 *.java 文件对应的 Class 类进行加锁。而 synchronized 关键字加到非 static 静态方法上就是给对象加锁。\r\n\r\n#### 多线程的死锁\r\n\r\n\r\n\r\n### volatile 关键字\r\n\r\n作用：使变量在多个线程间可见。\r\n\r\n通过使用 volatile 关键字，强制的从公共内存中读取变量的值。使用 volatile 关键字增加了实例变量在多个线程之间的可见性，但 volatile 关键字最致命的缺点就是不支持原子性。\r\n\r\n关键字 synchronized 和 volatile 比较：\r\n\r\n+ 关键字 volatile 是线程同步的轻量实现，所以 volatile 性能肯定要比 synchronized 要好，并且 volatile 只能修饰于变量，而 synchronized 可以修饰方法，以及代码块。\r\n\r\n+ 多线程访问 volatile 不会发生阻塞，而 synchronized 会出现阻塞。\r\n\r\n+ volatile 能保证数据的可见性，但不能保证原子性；而 synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公有内存中的数据做同步。\r\n\r\n+ 关键字 volatile 解决的是变量在多个线程之间的可见性；而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\r\n\r\n  ​\r\n\r\n\r\n\r\n## 第三章 —— 线程间通信\r\n\r\n技术点：\r\n\r\n+ 使用 wait/notify 实现线程间的通信\r\n+ 生产者/消费者模式的实现\r\n+ 方法 join 的使用\r\n+ ThreadLocal 类的使用\r\n\r\n\r\n### 等待/通知机制\r\n\r\nwait 使线程停止运行，notify 使停止的线程继续运行。\r\n\r\n关键字 synchronized 可以将任何一个 Object 对象作为同步对象看待，而 Java 为每个 Object 都实现了 wait() 和 notify() 方法，他们必须用在被 synchronized 同步的 Object 的临界区内。通过调用 wait 方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁。而 notify 操作可以唤醒一个因调用了 wait 方法而处于阻塞状态的线程，使其进入就绪状态。被重新唤醒的线程会试图重新获得临界区的控制权，继续执行临界区内 wait 之后的代码。\r\n\r\nwait 方法可以使调用该方法的线程释放共享资源的锁，从运行状态退出，进入等待状态，直到再次被唤醒。\r\n\r\nnotify() 方法可以随机唤醒等待对列中等待同一共享资源的一个线程，并使该线程退出等待状态，进入可运行状态。\r\n\r\nnotifyAll() 方法可以随机唤醒等待对列中等待同一共享资源的所有线程，并使这些线程退出等待状态，进入可运行状态。\r\n\r\n#### 线程状态示意图：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/thread-state.jpg)\r\n\r\n+ 新创建一个线程对象后，在调用它的 start() 方法，系统会为此线程分配 CPU 资源，使其处于 Runnable（可运行）状态，如果线程抢占到 CPU 资源，此线程就会处于 Running （运行）状态\r\n\r\n+ Runnable 和 Running 状态之间可以相互切换，因为线程有可能运行一段时间后，有其他优先级高的线程抢占了 CPU 资源，此时线程就从 Running 状态变成了 Runnable 状态。\r\n\r\n  线程进入 Runnable 状态有如下几种情况：\r\n\r\n  + 调用 sleep() 方法后经过的时间超过了指定的休眠时间\r\n  + 线程调用的阻塞 IO 已经返回，阻塞方法执行完毕\r\n  + 线程成功的获得了试图同步的监视器\r\n  + 线程正在等待某个通知，其他线程发出了通知\r\n  + 处于挂状态的线程调用了 resume 恢复方法\r\n\r\n+ Blocked 是阻塞的意思，例如线程遇到一个 IO 操作，此时 CPU 处于空闲状态，可能会转而把 CPU 时间片分配给其他线程，这时也可以称为 “暂停”状态。Blocked 状态结束之后，进入 Runnable 状态，等待系统重新分配资源。\r\n\r\n  出现阻塞状态的有如下几种情况：\r\n\r\n  + 线程调用 sleep 方法，主动放弃占用的处理器资源\r\n  + 线程调用了阻塞式 IO 方法，在该方法返回之前，该线程被阻塞\r\n  + 线程试图获得一个同步监视器，但该同步监视器正在被其他线程所持有\r\n  + 线程等待某个通知\r\n  + 程序调用了 suspend 方法将该线程挂起\r\n\r\n+ run 方法运行结束后进入销毁阶段，整个线程执行完毕。\r\n\r\n#### 生产者/消费者模式实现\r\n\r\n一个生产者，一个消费者\r\n\r\n存储值对象：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread5;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 存储值对象\r\n */\r\npublic class ValueObject\r\n{\r\n    public static String value = \"\";\r\n}\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread5;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 生产者\r\n */\r\npublic class Product\r\n{\r\n    private String lock;\r\n\r\n    public Product(String lock) {\r\n        this.lock = lock;\r\n    }\r\n\r\n    public void setValue() {\r\n        synchronized (lock) {\r\n            if (!ValueObject.value.equals(\"\")) {\r\n                try {\r\n                    lock.wait();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            String value = System.currentTimeMillis() + \"_\" + System.nanoTime();\r\n            System.out.println(\"生产者 set 的值是：\" + value);\r\n            ValueObject.value = value;\r\n            lock.notify();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread5;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 消费者\r\n */\r\npublic class Resume\r\n{\r\n    private String lock;\r\n\r\n    public Resume(String lock) {\r\n        this.lock = lock;\r\n    }\r\n\r\n    public void getValue() {\r\n        synchronized (lock) {\r\n            if (ValueObject.value.equals(\"\")) {\r\n                try {\r\n                    lock.wait();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            System.out.println(\"消费者 get 的值：\" + ValueObject.value);\r\n            ValueObject.value = \"\";\r\n            lock.notify();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n生产者线程：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread5;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 生产者线程\r\n */\r\npublic class ProductThread extends Thread\r\n{\r\n    private Product p;\r\n\r\n    public ProductThread(Product p) {\r\n        this.p = p;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            p.setValue();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n消费者线程：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread5;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 消费者线程\r\n */\r\npublic class ResumeThread extends Thread\r\n{\r\n    private Resume r;\r\n\r\n    public ResumeThread(Resume r) {\r\n        this.r = r;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            r.getValue();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n主函数：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread5;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 一个生产者一个消费者测试\r\n */\r\npublic class Test\r\n{\r\n    public static void main(String[] args) {\r\n        String str = new String(\"\");\r\n        Product p = new Product(str);\r\n        Resume r = new Resume(str);;\r\n        ProductThread pt = new ProductThread(p);\r\n        ResumeThread rt = new ResumeThread(r);\r\n        pt.start();\r\n        rt.start();\r\n    }\r\n}\r\n```\r\n\r\n题目：创建20个线程，其中10个线程是将数据备份到数据库A，另外10个线程将数据备份到数据库B中去，并且备份数据库A和备份数据库B是交叉进行的。\r\n\r\n工具类：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread6;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n * 创建20个线程，其中10个线程是将数据备份到数据库A，另外10个线程将数据备份到数据库B中去，并且\r\n * 备份数据库A和备份数据库B是交叉进行的\r\n */\r\npublic class DBTools\r\n{\r\n    volatile private boolean prevIsA = false;\r\n\r\n    //确保A备份先进行\r\n    synchronized public void backA() {\r\n        while (prevIsA == true) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        for (int i = 0; i < 5; i++) {\r\n            System.out.println(\"AAAAA\");\r\n        }\r\n        prevIsA = true;\r\n        notifyAll();\r\n    }\r\n\r\n    synchronized public void backB() {\r\n        while (prevIsA == false) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        for (int i = 0; i < 5; i++) {\r\n            System.out.println(\"BBBBB\");\r\n        }\r\n        prevIsA = false;\r\n        notifyAll();\r\n    }\r\n}\r\n```\r\n\r\n备份A先线程：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread6;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n */\r\npublic class ThreadA extends Thread\r\n{\r\n    private DBTools dbTools;\r\n\r\n    public ThreadA(DBTools dbTools) {\r\n        this.dbTools = dbTools;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        dbTools.backA();\r\n    }\r\n}\r\n```\r\n\r\n备份B线程：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread6;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n */\r\npublic class ThreadB extends Thread\r\n{\r\n    private DBTools dbTools;\r\n\r\n    public ThreadB(DBTools dbTools) {\r\n        this.dbTools = dbTools;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        dbTools.backB();\r\n    }\r\n}\r\n```\r\n\r\n测试：\r\n\r\n```java\r\npackage com.zhisheng.thread.thread6;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/3.\r\n */\r\npublic class Test\r\n{\r\n    public static void main(String[] args) {\r\n        DBTools dbTools = new DBTools();\r\n        for (int i = 0; i < 20; i++) {\r\n            ThreadB tb = new ThreadB(dbTools);\r\n            tb.start();\r\n            ThreadA ta = new ThreadA(dbTools);\r\n            ta.start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### Join 方法的使用\r\n\r\n作用：等待线程对象销毁\r\n\r\njoin 方法具有使线程排队运行的作用，有些类似同步的运行效果。join 与 synchronized 的区别是：join 在内部使用 wait() 方法进行等待，而 synchronized 关键字使用的是 “对象监视器” 原理做为同步。\r\n\r\n在 join 过程中，如果当前线程对象被中断，则当前线程出现异常。\r\n\r\n方法 join(long) 中的参数是设定等待的时间。\r\n\r\n```java\r\n/**\r\n     * 等待该线程终止的时间最长为 millis 毫秒。超时为 0 意味着要一直等下去。\r\n     * Waits at most {@code millis} milliseconds for this thread to\r\n     * die. A timeout of {@code 0} means to wait forever.\r\n     *\r\n     * <p> This implementation uses a loop of {@code this.wait} calls\r\n     * conditioned on {@code this.isAlive}. As a thread terminates the\r\n     * {@code this.notifyAll} method is invoked. It is recommended that\r\n     * applications not use {@code wait}, {@code notify}, or\r\n     * {@code notifyAll} on {@code Thread} instances.\r\n     *\r\n     * @param  millis\r\n     *         the time to wait in milliseconds\r\n     *\r\n     * @throws  IllegalArgumentException\r\n     *          if the value of {@code millis} is negative\r\n     *\r\n     * @throws  InterruptedException\r\n     *          if any thread has interrupted the current thread. The\r\n     *          <i>interrupted status</i> of the current thread is\r\n     *          cleared when this exception is thrown.\r\n     */\r\n    public final synchronized void join(long millis)\r\n    throws InterruptedException {\r\n        long base = System.currentTimeMillis();\r\n        long now = 0;\r\n        if (millis < 0) {\r\n            throw new IllegalArgumentException(\"timeout value is negative\");\r\n        if (millis == 0) {\r\n            while (isAlive()) {\r\n                wait(0);\r\n            }\r\n        } else {\r\n            while (isAlive()) {\r\n                long delay = millis - now;\r\n                if (delay <= 0) {\r\n                    break;\r\n                }\r\n                wait(delay);\r\n                now = System.currentTimeMillis() - base;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n### 类  ThreadLocal  的使用\r\n\r\n该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或\r\nset 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的\r\nprivate static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。\r\n\r\n#### get() 方法\r\n\r\n```java\r\npublic T get() {\r\n        Thread t = Thread.currentThread();\r\n        ThreadLocalMap map = getMap(t);\r\n        if (map != null) {\r\n            ThreadLocalMap.Entry e = map.getEntry(this);\r\n            if (e != null) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                T result = (T)e.value;\r\n                return result;\r\n            }\r\n        }\r\n        return setInitialValue();\r\n    }\r\n```\r\n\r\n返回此线程局部变量的当前线程副本中的值。如果变量没有用于当前线程的值，则先将其初始化为调用 initialValue() 方法返回的值。\r\n\r\n### InheritableThreadLocal 类的使用\r\n\r\n该类扩展了 ThreadLocal，为子线程提供从父线程那里继承的值：在创建子线程时，子线程会接收所有可继承的线程局部变量的初始值，以获得父线程所具有的值。通常，子线程的值与父线程的值是一致的；但是，通过重写这个类中的 childValue 方法，子线程的值可以作为父线程值的一个任意函数。\r\n\r\n当必须将变量（如用户 ID 和 事务 ID）中维护的每线程属性（per-thread-attribute）自动传送给创建的所有子线程时，应尽可能地采用可继承的线程局部变量，而不是采用普通的线程局部变量。\r\n\r\n\r\n\r\n## 第四章 ——  Lock 的使用\r\n\r\n### 使用 ReentrantLock 类\r\n\r\n一个可重入的互斥锁 Lock，它具有与使用 `synchronized` 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。\r\n\r\n`ReentrantLock` 将由最近成功获得锁，并且还没有释放该锁的线程所*拥有*。当锁没有被另一个线程所拥有时，调用 `lock` 的线程将成功获取该锁并返回。如果当前线程已经拥有该锁，此方法将立即返回。可以使用 `isHeldByCurrentThread()`和 `getHoldCount()`方法来检查此情况是否发生。\r\n\r\n此类的构造方法接受一个可选的*公平* 参数。当设置为 `true` 时，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。否则此锁将无法保证任何特定访问顺序。与采用默认设置（使用不公平锁）相比，使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量（即速度很慢，常常极其慢），但是在获得锁和保证锁分配的均衡性时差异较小。不过要注意的是，公平锁不能保证线程调度的公平性。因此，使用公平锁的众多线程中的一员可能获得多倍的成功机会，这种情况发生在其他活动线程没有被处理并且目前并未持有锁时。还要注意的是，未定时的 `tryLock`方法并没有使用公平设置。因为即使其他线程正在等待，只要该锁是可用的，此方法就可以获得成功。\r\n\r\n建议*总是* 立即实践，使用 `lock` 块来调用 `try`，在之前/之后的构造中，最典型的代码如下：\r\n\r\n```java\r\nclass X {\r\n   private final ReentrantLock lock = new ReentrantLock();\r\n   // ...\r\n\r\n   public void m() {\r\n     lock.lock();  // block until condition holds\r\n     try {\r\n       // ... method body\r\n     } finally {\r\n       lock.unlock()\r\n     }\r\n   }\r\n }\r\n```\r\n\r\n### Condition\r\n\r\nCondition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。\r\n\r\n假定有一个绑定的缓冲区，它支持 put 和 take 方法。如果试图在空的缓冲区上执行 take 操作，则在某一个项变得可用之前，线程将一直阻塞；如果试图在满的缓冲区上执行 put 操作，则在有空间变得可用之前，线程将一直阻塞。我们喜欢在单独的等待 set 中保存 put 线程和 take 线程，这样就可以在缓冲区中的项或空间变得可用时利用最佳规划，一次只通知一个线程。可以使用两个 Condition 实例来做到这一点。\r\n\r\n```java\r\nclass BoundedBuffer {\r\n   final Lock lock = new ReentrantLock();\r\n   final Condition notFull  = lock.newCondition();\r\n   final Condition notEmpty = lock.newCondition();\r\n\r\n   final Object[] items = new Object[100];\r\n   int putptr, takeptr, count;\r\n\r\n   public void put(Object x) throws InterruptedException {\r\n     lock.lock();\r\n     try {\r\n       while (count == items.length)\r\n         notFull.await();\r\n       items[putptr] = x;\r\n       if (++putptr == items.length) putptr = 0;\r\n       ++count;\r\n       notEmpty.signal();\r\n     } finally {\r\n       lock.unlock();\r\n     }\r\n   }\r\n\r\n   public Object take() throws InterruptedException {\r\n     lock.lock();\r\n     try {\r\n       while (count == 0)\r\n         notEmpty.await();\r\n       Object x = items[takeptr];\r\n       if (++takeptr == items.length) takeptr = 0;\r\n       --count;\r\n       notFull.signal();\r\n       return x;\r\n     } finally {\r\n       lock.unlock();\r\n     }\r\n   }\r\n }\r\n```\r\n\r\n### 正确使用 Condition 实现等待/通知\r\n\r\nMyService.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread9;\r\n\r\nimport java.util.concurrent.locks.Condition;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class MyService\r\n{\r\n    private Lock lock = new ReentrantLock();\r\n    private Condition condition = lock.newCondition();\r\n\r\n    public void await() {\r\n        lock.lock();\r\n        try {\r\n            System.out.println(\"await A\");\r\n            condition.await();//使当前执行的线程处于等待状态 waiting\r\n            System.out.println(\"await B\");\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            lock.unlock();\r\n            System.out.println(\"释放锁\");\r\n        }\r\n    }\r\n\r\n    public void signal() {\r\n        lock.lock();\r\n        System.out.println(\"signal A\");\r\n        condition.signal();\r\n        System.out.println(\"signal B\");\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\nThreadA.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread9;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class ThreadA extends Thread\r\n{\r\n    private MyService service;\r\n\r\n    public ThreadA(MyService service) {\r\n        this.service = service;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        service.await();\r\n    }\r\n}\r\n```\r\n\r\nTest.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread9;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class Test\r\n{\r\n    public static void main(String[] args) throws InterruptedException {\r\n        MyService service = new MyService();\r\n        ThreadA ta = new ThreadA(service);\r\n        ta.start();\r\n        Thread.sleep(5000);\r\n        service.signal();\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n```java\r\nawait A\r\nsignal A\r\nsignal B\r\nawait B\r\n释放锁\r\n```\r\n\r\nObject 类中的 wait() 方法相当于 Condition 类中 await() 方法\r\n\r\nObject 类中的 wait(long time) 方法相当于 Condition 类中 await(long time, TimeUnit unit) 方法\r\n\r\nObject 类中的 notify() 方法相当于 Condition 类中 signal() 方法\r\n\r\nObject 类中的 notifyAll() 方法相当于 Condition 类中 signalAll() 方法\r\n\r\n\r\n\r\n题目：实现生产者与消费者  一对一交替打印\r\n\r\nMyService.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread10;\r\n\r\nimport java.util.concurrent.locks.Condition;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n * 实现生产者与消费者  一对一·交替打印\r\n */\r\npublic class MyService\r\n{\r\n    private Lock lock = new ReentrantLock();\r\n    private Condition condition = lock.newCondition();\r\n    private  boolean flag = false;\r\n\r\n    public void setValue() {\r\n        lock.lock();\r\n        while (flag == true) {\r\n            try {\r\n                condition.await();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(\"SetValue  AAAAAA\");\r\n        flag = true;\r\n        condition.signal();\r\n        lock.unlock();\r\n    }\r\n\r\n    public void getValue() {\r\n        lock.lock();\r\n        while (flag == false) {\r\n            try {\r\n                condition.await();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(\"GetValue BBBB\");\r\n        flag = false;\r\n        condition.signal();\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\nThreadA.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread10;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class ThreadA extends Thread\r\n{\r\n    private MyService service;\r\n\r\n    public ThreadA(MyService service) {\r\n        this.service = service;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\r\n            service.setValue();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThreadB.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread10;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class ThreadB extends Thread\r\n{\r\n    private MyService service;\r\n\r\n    public ThreadB(MyService service) {\r\n        this.service = service;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\r\n            service.getValue();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTest.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread10;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class Test\r\n{\r\n    public static void main(String[] args) {\r\n        MyService service = new MyService();\r\n        ThreadA ta = new ThreadA(service);\r\n        ThreadB tb = new ThreadB(service);\r\n        ta.start();\r\n        tb.start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\ngetHoldCount() 查询当前线程保持此锁定的个数，也就是调用 lock() 的方法\r\n\r\ngetQueueLength() 返回正等待获取此锁定的线程估计数\r\n\r\ngetWaitQueueLength() 返回等待与此锁定相关的给定条件 Condition 的线程估计数\r\n\r\nhasQueuedThread() 查询指定的线程是否正在等待获取此锁定\r\n\r\nhasQueuedThreads() 查询是否有线程正在等待获取此锁定\r\n\r\nhasWaiters() 查询是否有线程正在等待与此锁定有关的 condition 条件\r\n\r\nisFair() 判断是否是公平锁（默认下 ReentrantLock类使用的是非公平锁）\r\n\r\nisHeldByCurrentThread() 查询当前线程是否保持此锁定\r\n\r\nisLocked() 查询此锁定是否由任意线程保持\r\n\r\nlockInterruptibly() 如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常\r\n\r\ntryLock() 仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定\r\n\r\ntryLock(long time, TimeUtil util) 如果锁定在给定的等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。\r\n\r\n### 使用 ReentrantReadWriteLock 类\r\n\r\n读写互斥：\r\n\r\nMyService.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread11;\r\n\r\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class MyService\r\n{\r\n    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\r\n\r\n    public void read() {\r\n        lock.readLock().lock();\r\n        System.out.println(Thread.currentThread().getName() + \" Read AAA  \" + System.currentTimeMillis());\r\n        try {\r\n            Thread.sleep(10000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        lock.readLock().unlock();\r\n    }\r\n\r\n    public void write() {\r\n        lock.writeLock().lock();\r\n        System.out.println(Thread.currentThread().getName() + \" write BBB \" + System.currentTimeMillis());\r\n        try {\r\n            Thread.sleep(10000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        lock.writeLock().unlock();\r\n    }\r\n}\r\n```\r\n\r\nThreadA.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread11;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class ThreadA extends Thread\r\n{\r\n    private MyService service;\r\n\r\n    public ThreadA(MyService service) {\r\n        this.service = service;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        service.read();\r\n    }\r\n}\r\n```\r\n\r\nThreadB.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread11;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class ThreadB extends Thread\r\n{\r\n    private MyService service;\r\n\r\n    public ThreadB(MyService service) {\r\n        this.service = service;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        service.write();\r\n    }\r\n}\r\n```\r\n\r\nTest.java\r\n\r\n```java\r\npackage com.zhisheng.thread.Thread11;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class Test\r\n{\r\n    public static void main(String[] args) throws InterruptedException {\r\n        MyService service = new MyService();\r\n        ThreadA ta = new ThreadA(service);\r\n        ta.setName(\"A\");\r\n        ta.start();\r\n        Thread.sleep(1000);\r\n        ThreadB tb = new ThreadB(service);\r\n        tb.setName(\"B\");\r\n        tb.start();\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n```\r\nA Read AAA  1496556770402\r\nB write BBB 1496556780402\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 第六章 —— 单例模式与多线程\r\n\r\n推荐文章 [《深入浅出单实例Singleton设计模式》](http://blog.csdn.net/tzs_1041218129/article/details/51246419)\r\n\r\n### 立即加载模式 / “饿汉模式”\r\n\r\n立即加载：使用类的时候已经将对象创建完毕，new 实例化\r\n\r\n```java\r\npublic class MyObject\r\n{\r\n    private static MyObject object = new MyObject();\r\n    private MyObject() {\r\n    }\r\n    public static MyObject getInstance() {\r\n        return object;\r\n    }\r\n}\r\n```\r\n\r\n### 延迟加载 / “ 懒汉模式 ”\r\n\r\n就是在调用 get 的时候实例才被创建。在 get() 方法中进行 new 实例化。\r\n\r\n```java\r\npublic class MyObject\r\n{\r\n    private  static  MyObject object;\r\n    private MyObject() {\r\n    }\r\n    public static MyObject getInstance() {\r\n        if (object != null) {\r\n        } else {\r\n            object = new MyObject();\r\n        }\r\n        return object;\r\n    }\r\n}\r\n```\r\n\r\n使用 DCL 双重检查锁，解决“懒汉模式”遇到的多线程问题\r\n\r\n```java\r\npublic class MyObject\r\n{\r\n    private  volatile static  MyObject object;\r\n    private MyObject() {\r\n    }\r\n    //synchronized\r\n    public static MyObject getInstance() {\r\n        if (object != null) {\r\n        } else {\r\n            synchronized (MyObject.class) {\r\n                if (object == null) {\r\n                    object = new MyObject();\r\n                }\r\n            }\r\n        }\r\n        return object;\r\n    }\r\n}\r\n```\r\n\r\n### 使用静态内部类实现单例模式\r\n\r\n```java\r\npublic class MyObject\r\n{\r\n    private static class MyObjectHandler\r\n    {\r\n        private static MyObject object = new MyObject();\r\n    }\r\n    private MyObject() {\r\n    }\r\n    public static MyObject getInstance() {\r\n        return MyObjectHandler.object;\r\n    }\r\n}\r\n```\r\n\r\n### 序列化与反序列化的单例模式实现\r\n\r\nMyObject.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread15;\r\n\r\nimport java.io.ObjectStreamException;\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class MyObject implements Serializable\r\n{\r\n    private static final long serialVersionUID =  888L;\r\n    private static class MyObjectHandler\r\n    {\r\n        private static final MyObject object = new MyObject();\r\n    }\r\n    private MyObject() {\r\n    }\r\n    public static  MyObject getInstance() {\r\n        return MyObjectHandler.object;\r\n    }\r\n    protected Object readResolve() throws ObjectStreamException {\r\n        System.out.println(\"调用了readResolve方法！\");\r\n        return MyObjectHandler.object;\r\n    }\r\n}\r\n```\r\n\r\nSaveAndRead.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread15;\r\n\r\nimport java.io.*;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class SaveAndRead\r\n{\r\n    public static void main(String[] args) {\r\n        try {\r\n            MyObject object = MyObject.getInstance();\r\n            FileOutputStream fos = new FileOutputStream(new File(\"fos.txt\"));\r\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\r\n            oos.writeObject(object);\r\n            oos.close();\r\n            fos.close();\r\n            System.out.println(object.hashCode());\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        try {\r\n            FileInputStream fis = new FileInputStream(new File(\"fos.txt\"));\r\n            ObjectInputStream ois = new ObjectInputStream(fis);\r\n            MyObject o = (MyObject) ois.readObject();\r\n            ois.close();\r\n            fis.close();\r\n            System.out.println(o.hashCode());\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } catch (ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n这里主要要指出 MyObject.java 中 readResolve 方法\r\n\r\n```java\r\n protected Object readResolve() throws ObjectStreamException {\r\n        System.out.println(\"调用了readResolve方法！\");\r\n        return MyObjectHandler.object;\r\n    }\r\n```\r\n\r\n方法 readResolve 允许 class 在反序列化返回对象前替换、解析在流中读出来的对象。实现 readResolve 方法，一个 class 可以直接控制反序化返回的类型和对象引用。\r\n\r\n方法 readResolve 会在 ObjectInputStream 已经读取一个对象并在准备返回前调用。ObjectInputStream 会检查对象的 class 是否定义了 readResolve 方法。如果定义了，将由 readResolve 方法指定返回的对象。返回对象的类型一定要是兼容的，否则会抛出 ClassCastException 。\r\n\r\n### 使用 static 代码块实现单例模式\r\n\r\n```java\r\npackage com.zhisheng.thread.thread16;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class MyObject\r\n{\r\n    private static MyObject instance = null;\r\n    private MyObject() {\r\n    }\r\n    static {\r\n        instance = new MyObject();\r\n    }\r\n    public static MyObject getInstance() {\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\nThreadA.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread16;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class ThreadA extends Thread\r\n{\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 5; i++) {\r\n            System.out.println(MyObject.getInstance().hashCode());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTest.java\r\n\r\n```java\r\npackage com.zhisheng.thread.thread16;\r\n\r\n/**\r\n * Created by 10412 on 2017/6/4.\r\n */\r\npublic class Test\r\n{\r\n    public static void main(String[] args) {\r\n        ThreadA ta1 = new ThreadA();\r\n        ThreadA ta2 = new ThreadA();\r\n        ThreadA ta3 = new ThreadA();\r\n        ta1.start();\r\n        ta2.start();\r\n        ta3.start();\r\n    }\r\n}\r\n```\r\n\r\n### 使用枚举数据类型实现单例模式\r\n\r\n在使用枚举类时，构造方法会被自动调用，也可以应用这个特性实现单例模式。\r\n\r\n```java\r\npublic class MyObject {\r\n    private enum MyEnumSingleton{\r\n        INSTANCE;\r\n        private Resource resource;\r\n        private MyEnumSingleton(){\r\n            resource = new Resource();\r\n        }\r\n        public Resource getResource(){\r\n            return resource;\r\n        }\r\n    }\r\n    public static Resource getResource(){\r\n        return MyEnumSingleton.INSTANCE.getResource();\r\n    }\r\n}\r\n```\r\n\r\n测试：\r\n\r\n```java\r\nimport test.MyObject;\r\n\r\npublic class Run {\r\n    class MyThread extends Thread {\r\n        @Override\r\n        public void run() {\r\n            for (int i = 0; i < 5; i++) {\r\n                System.out.println(MyObject.getResource().hashCode());\r\n            }\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n        Run.MyThread t1 = new Run().new MyThread();\r\n        Run.MyThread t2 = new Run().new MyThread();\r\n        Run.MyThread t3 = new Run().new MyThread();\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n\r\n    }\r\n}\r\n```\r\n\r\n这里再推荐一篇 stackoverflow 上的一个问题回答： [What is an efficient way to implement a singleton pattern in Java?](https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java)\r\n\r\n\r\n\r\n## 总结\r\n\r\n本篇文章是我读 《Java多线程编程核心技术》 的笔记及自己的一些总结，觉得不错，欢迎点赞和转发。\r\n\r\n\r\n', 1, 'post', 'publish', 'Java', 'Java', 109, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (4, 'HashMap、Hashtable、HashSet 和 ConcurrentHashMap 的比较', 'HashMap-HashTable', 1619500000, 1497323623, 'HashMap 和 Hashtable 的比较是 Java 面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap 的工作原理、ArrayList 与 Vector 的比较以及这个问题是有关 Java 集合框架的最经典的问题。Hashtable 是个过时的集合类，存在于 Java API 中很久了。在 Java 4 中被重写了，实现了 Map 接口，所以自此以后也成了 Java 集合框架中的一部分。Hashtable 和 HashMap 在 Java 面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何 Java 面试之前，都不要忘了准备这一题。\r\n<!-- more -->\r\n这篇文章中，我们不仅将会看到 HashMap 和 Hashtable 的区别，还将看到它们之间的相似之处。\r\n\r\n### HashMap 和 Hashtable 的区别\r\n\r\nHashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步 (synchronization)，以及速度。\r\n\r\n1. HashMap 几乎可以等价于 Hashtable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值 (value)，而 Hashtable 则不行)。\r\n2. HashMap 是非 synchronized，而 Hashtable 是 synchronized，这意味着 Hashtable 是线程安全的，多个线程可以共享一个 Hashtable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。\r\n3. 另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是Enumeration 和 Iterato r的区别。\r\n4. 由于 Hashtable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 Hashtable。\r\n5. HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。\r\n\r\n### 要注意的一些重要术语：\r\n\r\n1) sychronized 意味着在一次仅有一个线程能够更改 Hashtable。就是说任何线程要更新 Hashtable 时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新 Hashtable。\r\n\r\n2) Fail-safe 和 iterator 迭代器相关。如果某个集合对象创建了 Iterator 或者 ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出 ConcurrentModificationException 异常。但其它线程可以通过 set() 方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用 set() 方法，将会抛出 IllegalArgumentException 异常。\r\n\r\n3) 结构上的更改指的是删除或者插入一个元素，这样会影响到 map 的结构。\r\n\r\n### 我们能否让 HashMap 同步？\r\n\r\nHashMap 可以通过下面的语句进行同步：\r\nMap m = Collections.synchronizeMap(hashMap);\r\n\r\n### 结论\r\n\r\nHashtable 和 HashMap 有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用 Java 5 或以上的话，请使用 ConcurrentHashMap 吧。\r\n\r\n转载自：[HashMap和Hashtable的区别](http://www.importnew.com/7010.html)\r\n\r\n***\r\n\r\n关于 HashMap 线程不安全这一点，《Java并发编程的艺术》一书中是这样说的：\r\n\r\n> HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近 100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。\r\n\r\n原因：\r\n\r\n+ [疫苗：JAVA HASHMAP的死循环 —— 酷壳](http://coolshell.cn/articles/9606.html)\r\n+ [HashMap在java并发中如何发生死循环](http://firezhfox.iteye.com/blog/2241043)\r\n+ [How does a HashMap work in JAVA](http://coding-geek.com/how-does-a-hashmap-work-in-java/)\r\n\r\n***\r\n\r\n下面的是自己有道云笔记中记录的：\r\n\r\n**HashMap ， HashTable 和 HashSet 区别**\r\n\r\n1.  关于 HashMap 的一些说法：\r\n\r\na)  HashMap 实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap 的底层结构是一个数组，数组中的每一项是一条链表。\r\n\r\nb)  HashMap 的实例有俩个参数影响其性能： “初始容量” 和 装填因子。\r\n\r\nc)  HashMap 实现不同步，线程不安全。  HashTable 线程安全\r\n\r\nd)  HashMap 中的 key-value 都是存储在 Entry 中的。\r\n\r\ne)  HashMap 可以存 null 键和 null 值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode() 方法和 equals 方法保证键的唯一性\r\n\r\nf)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap 是采用拉链法解决哈希冲突的。\r\n\r\n注： 链表法是将相同 hash 值的对象组成一个链表放在 hash 值对应的槽位；\r\n\r\n用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。\r\n\r\n拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。\r\n\r\n   \r\n\r\n2.  Hashtable 和 HashMap 的区别：\r\n\r\na)   继承不同。\r\n\r\n public class Hashtable extends Dictionary implements Map\r\n\r\npublic class HashMap extends  AbstractMap implements Map\r\n\r\nb)  Hashtable 中的方法是同步的，而 HashMap 中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用 Hashtable，但是要使用 HashMap 的话就要自己增加同步处理了。\r\n\r\nc)  Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。\r\n\r\nd)  两个遍历方式的内部实现上不同。Hashtable、HashMap 都使用了Iterator。而由于历史原因，Hashtable还使用了 Enumeration 的方式 。\r\n\r\ne)  哈希值的使用不同，HashTable 直接使用对象的 hashCode。而 HashMap 重新计算 hash 值。\r\n\r\nf)  Hashtable 和 HashMap 它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable 中 hash 数组默认大小是11，增加的方式是 old*2+1。HashMap 中 hash 数组的默认大小是 16，而且一定是2的指数。\r\n\r\n注：  HashSet 子类依靠 hashCode() 和 equal() 方法来区分重复元素。\r\n\r\nHashSet 内部使用 Map 保存数据，即将 HashSet 的数据作为 Map 的 key 值保存，这也是 HashSet 中元素不能重复的原因。而 Map 中保存 key 值的,会去判断当前 Map 中是否含有该 Key 对象，内部是先通过 key 的hashCode, 确定有相同的 hashCode 之后，再通过 equals 方法判断是否相同。\r\n\r\n***\r\n\r\n《HashMap 的工作原理》\r\n\r\nHashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道 Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！\r\n\r\n### 先来些简单的问题\r\n\r\n**“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”**\r\n\r\n几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：\r\n\r\n**“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”**\r\n\r\n你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”\r\n\r\n但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：\r\n\r\n**“当两个对象的hashcode相同会发生什么？”** \r\n\r\n从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：\r\n\r\n**“如果两个键的hashcode相同，你如何获取值对象？”**\r\n\r\n 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。\r\n\r\n其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！\r\n\r\n许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。\r\n\r\n如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。\r\n\r\n**“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”**\r\n\r\n除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。\r\n\r\n如果你能够回答这道问题，下面的问题来了：\r\n\r\n**“你了解重新调整HashMap大小存在什么问题吗？”**\r\n\r\n你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。\r\n\r\n当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）\r\n\r\n热心的读者贡献了更多的关于HashMap的问题：\r\n\r\n1. **为什么String, Interger这样的wrapper类适合作为键？** \r\n\r\n   String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。\r\n\r\n2. **我们可以使用自定义的对象作为键吗？** \r\n\r\n   这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。\r\n\r\n3. **我们可以使用CocurrentHashMap来代替Hashtable吗？**\r\n\r\n   这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看 [这篇博客](http://javarevisited.blogspot.sg/2011/04/difference-between-concurrenthashmap.html) 查看Hashtable和ConcurrentHashMap的区别。\r\n\r\n我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：\r\n\r\n- hashing的概念\r\n- HashMap中解决碰撞的方法\r\n- equals()和hashCode()的应用，以及它们在HashMap中的重要性\r\n- 不可变对象的好处\r\n- HashMap多线程的条件竞争\r\n- 重新调整HashMap的大小\r\n\r\n### 总结\r\n\r\n#### HashMap的工作原理\r\n\r\nHashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。\r\n\r\n当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。\r\n\r\n因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章:\r\n\r\n- [HashMap和Hashtable的区别](http://www.importnew.com/7010.html)\r\n- [HashMap和HashSet的区别](http://www.importnew.com/6931.html)\r\n\r\n转载自：[HashMap的工作原理](http://www.importnew.com/7099.html)\r\n\r\n***\r\n\r\n其他的 HashMap 学习资料：\r\n\r\n+ [jdk7中HashMap知识点整理](https://segmentfault.com/a/1190000003617333)\r\n+ [HashMap源码分析（四）put-jdk8-红黑树的引入](http://blog.csdn.net/q291611265/article/details/46797557)\r\n+ [JDK7与JDK8中HashMap的实现](https://my.oschina.net/hosee/blog/618953)\r\n+ [JDK1.8HashMap原理和源码分析(java面试收藏)](https://wenku.baidu.com/view/6e1035943968011ca30091cd.html)\r\n+ [谈谈ConcurrentHashMap1.7和1.8的不同实现](http://www.jianshu.com/p/e694f1e868ec)\r\n+ [jdk1.8的HashMap和ConcurrentHashMap](https://my.oschina.net/pingpangkuangmo/blog/817973)\r\n+ [ConcurrentHashMap源码分析（JDK8版本）](http://blog.csdn.net/u010723709/article/details/48007881)\r\n\r\n***\r\n\r\n### 最后\r\n\r\n谢谢阅读，如果可以的话欢迎大家转发和点赞。如需转载注明[原地址](www.54tianzhisheng.cn/2017/06/10/HashMap-Hashtable/)就行。\r\n\r\n群 528776268 欢迎各位大牛进群一起讨论。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/1473414112000.png)', 1, 'post', 'publish', 'Java,HashMap,HashTable,HashSet,ConcurrentHashMap', 'Java', 142, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (7, '面向对象的思考', NULL, 1619682749, 1620478142, '&emsp;&emsp;从写JAVA开始一直到今天也有一年多了，学习的时候网络上总是说JAVA是纯面向对象的语言。其实也不懂什么是面向对象，只是仿照着前人写代码，当然也百度过面向对象，只不过百度上的回答总是那么不够通俗易懂，只说什么封装，继承，多态之类的抽象概念，并不知道怎么写面向对象的代码，从C语言学到的面向过程化方法也在JAVA里面写，这样的代码写出来当然不够简洁优雅，没有拓展性，谈不上好代码。不过学习总是有一个循序渐进的过程，我在模仿的过程中逐渐的领悟了一些面向对象的概念，同时也明白了百度上的面向对象概念为什么这么抽象，因为实在是不好描述，这种概念只能够靠自己领悟，我在此也将自己的一些感悟记录下来。\r\n\r\n&emsp;&emsp;首先需要阐述的是面向对象是一种思想，而不是一种技术，这一点非常重要。面向对象，专业术语OOP，乍一看还以为让你找个对象看着它写代码，其实没任何关系。我认为与其叫面向对象编程还不如叫面向现实编程，面向对象的代码总是与现实业务有很好的对照性，如何写出与现实复杂业务对应的代码则是面向对象思想想要描述的。\r\n\r\n&emsp;&emsp;我们首先需要了解的就应该是抽象。这也是面向对象中非常重要的一步，好的抽象会让整个系统的拓展性更强，程序更加的健壮。那么什么是抽象呢？专业术语就是把众多事务的本质特征提出出来，映射成一个笼统的集合。例如“人”，我们可以从人抽象出一些特征，比如身高，性别，年龄等等，我们就说人是一个抽象集合，为什么要这么抽象呢，是为了可以复用代码，让我们不必写重复的代码，如果在程序的某一个地方用到了人，那么我们需要写出人这个类，倘若程序的另外一个地方用到了人怎么办呢，难道又重新写一次吗？这样显然不是优雅的设计，所以千呼万唤始出来的抽象就出现了，通过抽象，我们只需要粗略的描述某个事物，而不必关心内部的具体实现，我们抽象一次过后，在需要使用的地方直接使用就行了，直接new一个实例对象就可以使用了，这个人的身高性别等等属性都可以由你自己支配，只需要给相应的属性赋值就可以。我们在抽象类的时候不必关心具体的实现，我们只需要弄清我们需要什么东西即可，至于怎么实现，就不是抽象应该处理的事情了。\r\n\r\n&emsp;&emsp;其次就是继承，同样的，我们会阐述什么是继承和为什么需要继承，以及继承能做什么。继承也是为了提高代码的复用性，当然它还有解耦合等功能。上一段我们说到人这个抽象概念，同样的我们也可以抽象出男人和女人这两个抽象概念，让男人和女人去继承人这个类，为什么要这么做？这当中当然有内在逻辑，男人可以说是人，但人不能说成是男人，因为还有女人，所以我们的继承逻辑就非常明显了，男人和女人都应该继承人，因为他们都是人，而不能反过来，因为逻辑说不通。我们在此约定：将继承的类叫做子类，而被继承的类叫做父类。子类继承父类之后也拥有父类的一些方法和属性(具体看类的实现)，例如人会走，男人和女人都会走，所以我们不必在子类中写重复的代码去描述男人和女人会跑这件事(当然也可以重写父类方法)，所以我们提高了代码的复用性，上层代码比下层代码更加的通用，下层代码继承了上层代码的某些特性但是比上层代码特殊一些。不然则需要在父类和子类中都描述人会走这件事，很显然这是吃饱了没事做！也正是继承这个特性，让面向对象的语言非常的灵活，由此在前人的总结下出现了很多种设计模式(这是比较高级的技巧了，我暂时也没全部弄懂)，设计模式让整个系统的拓展性更好了，让代码更加健壮，由于本人水平有限，在此就不多阐述了，有能力和兴趣的朋友可以在网络上找到很多资料。\r\n\r\n&emsp;&emsp;接着需要了解的是封装，封装，从字面意思就可以知道，封着装起来，把数据和代码捆绑在一起，将你不想暴露的属性封起来，不给别人访问，将你可以给别人的访问的属性开放，以此实现不同属性的访问权限，总的来说，封装的目的就是对数据信息的控制。\r\n\r\n&emsp;&emsp;以上就是我总结的对面向对象的一些粗略的想法，可能不够成熟，也不够完善，但鉴于本人的水平以及时间关系也只能够啰嗦这么多了，如果想更进一步的了解不如去系统的学习，但面向对象是一种非常高深的思想，也是一种非常成熟的思想，想要参透还是很有难度的。在学习的过程中动手写代码是必不可少的，如果不会写就去模仿，抄代码也未尝不可，见得多了之后也就会写一些简单的代码了，而想要有更多的进步则必须动手写一些复杂的项目，在动手的过程中我相信进步会很快。最后我想说我非常不赞成学习完JavaSE之后直接学习springboot之类的框架，虽然学完了框架很快就可以动手写一些企业级项目，但是对学习并没有很大的帮助，你只是学会了使用，而真正的精髓则是框架的设计理念，我想，这才是我们需要学习的，毕竟每个人都不想只当一个螺丝钉，学习是没有尽头的，技术迭代的很快，要不断的学习才不会被淘汰。希望在大四实习的时候可以找到一份满意的实习工作，望诸位共勉！\r\n\r\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;  2021.3.24', 1, 'post', 'publish', 'Java', 'Java', 214, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (8, '关于JAVA中this关键字的指向问题', NULL, 1619682792, 1620360354, '在我刚开始学习JAVA时，JAVA中的this关键字给了我很大的疑惑，最终在网络上搜索了很久才弄明白this的用法，不得不说学习的过程中总是有一些挑战，幸亏有网络，感谢国家优秀的网络环境。闲话不多说，直接开始解释this关键字的指向问题。\r\n\r\n先来看一段简单的代码\r\n![请输入图片描述][1]\r\n\r\n这是一段非常简单的代码，在构造方法中出现了this.name=name这种写法。有些人可能非常不解，为什么构造方法的形参和私有属性名一模一样，这段语句到底是什么意思，很显然没有弄懂this的意义就会有这种疑问。大家可能学过计算机网络，计算机网络这门课程中讲过一个特殊的地址：0.0.0.0。这个地址就类似于this的作用，进来的是什么地址，这个0.0.0.0就是什么地址。同样的，这个this指向的就是当前对象，表示的是你使用的当前对象。上面的代码我在构造函数中输出了对象的地址，通过main方法new两个实例对象，看看它们的地址。\r\n![请输入图片描述][2]\r\n\r\n\r\n输出的结果如下\r\n![请输入图片描述][3]\r\n\r\n\r\n很显然两个对象的地址不同，我是使用this在无参构造中输出对象的，这也可以说明this指向的是当前对象，指向的是你使用的对象。你使用的是哪个实例对象，那么this就指向的是哪个实例对象。\r\n\r\n\r\n  [1]: https://i.loli.net/2021/05/07/p7EM6g8xjdkTAN4.png\r\n  [2]: https://i.loli.net/2021/05/07/3yRJpdsmuf2DOwT.png\r\n  [3]: https://i.loli.net/2021/05/07/WsPv1gKULQux6lS.png', 1, 'post', 'publish', 'Java', 'Java', 322, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (9, 'JAVA接口设计的好处', NULL, 1619701380, 1620537625, '   私以为接口是JAVA中一个非常棒的设计，因为C++中允许多重继承导致了二义性问题的出现，而JAVA中的接口正是为了解决多重继承所带来的问题而设计的。接口使我们写代码的方式更加的灵活，但是有很多朋友弄不清抽象类和接口如何选择，这篇文章不会围绕在抽象类和接口如何选择这个问题展开，但我会在文章末尾给出一个小建议告诉大家该如何选择。 <br>\r\n   接口，在类名前使用interface修饰就是一个接口了，语法十分的简单。我还记得最开始学习的时候在网络上查的资料说只要把接口当做一个比抽象类更加抽象的类就行了，随着学习的深入发现这种言论是十分的糊涂的，并不会让学习者更加的理解，反而会给学习者造成困扰，抽象类和接口是两个完全不同的东西。在面向对象的意义上，接口是“有没有”的关系，抽象类是“是不是”的关系，完全不能够混为一谈，但是实际在工作过程中也并没有很特意去区分，一般都不会使用抽象类，更多的是选择接口，接口带来的好处是十分显而易见的，下面我将借助面向对象中的多态特性来阐述为什么接口会使代码更加的灵活。\r\n   ![请输入图片描述][1]\r\n   ![请输入图片描述][2]\r\n   ![请输入图片描述][3]\r\n   ![请输入图片描述][4]\r\n   这是一段简单的组合结构，层次十分的清晰。\r\n   ![请输入图片描述][5]\r\n<br>\r\n   使用一个测试主类调用进食方法，结果如下\r\n   ![请输入图片描述][6]\r\n\r\n\r\n \r\n\r\n   很显然输出了预期的结果，但是我并没有在测试主类中new猫或者狗的实例对象然后分别调用它们的进食方法，我在主人类中把宠物进食的方法形参声明为AnimalBehavior，然后调用AnimalBehavior的eat方法，我只需要在主类中传入一个AnimalBehavior的实现类就够了，这里大家应该都明白了，这是向上转型带来的效果，设计模式这本书里讲解了JAVA的接口设计好处，书中的意思是为了享受向上转型带来的好处而设计接口，这句话是非常精辟的，代码的灵活性很大程度上都是依靠向上转型，当然接口的妙用不止如此，随着学习的深入，又会有面向接口编程这种说法了，在Servlet中响应http最原始的接口就是Servlet这个接口(前者的servlet指的是处理http请求的框架，而后者指的是这套框架中的一个接口，这个接口名字就叫servlet)，由于框架越来越先进，在使用mybatis持久层框架时我们甚至不需要编写接口的实现类，只需要写接口和配置文件就可以操作数据了，从这些方面接口带来的好处就可见一斑了。由于本人水平有限，能够讲述的也只有这么多，有兴趣的朋友可以百度查询更多的资料。 <br>\r\n   关于接口和抽象类的选择有一个原则，在一个方法有多种实现方式时就应该设计成抽象类或接口，若不明白如何选择，则优先选择接口。以后我会详细的讲解抽象类和接口该如何选择。\r\n                                                                         2021.3.29\r\n\r\n\r\n  [1]: https://i.loli.net/2021/05/07/oLY2mgb9SqB8Ia1.png\r\n  [2]: https://i.loli.net/2021/05/07/6MG7CpjPQlXgAwa.png\r\n  [3]: https://i.loli.net/2021/05/07/ou1wG5ytkmLb4eF.png\r\n  [4]: https://i.loli.net/2021/05/07/Ve9B27uGcp64xIw.png\r\n  [5]: https://i.loli.net/2021/05/07/UFvYt5POfJQrSzV.png\r\n  [6]: https://i.loli.net/2021/05/07/tsLFH6qzGXS1hU7.png', 1, 'post', 'publish', 'JAVA', 'Java', 185, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (10, '抽象类和接口的选择原则', NULL, 1619701593, 1620537573, '   上次的文章讲述了接口的带来的好处之后，我说会继续写一写如何在接口和抽象类之间选择，由于清明假期以及我最近一直在看AQS的实现并且还要上课，所以这篇文章推迟了很久，由于今天早上没课，终于狠下心起早床写完这篇。下面就直接进入正题。 <br>\r\n   其实接口和抽象类的选择原理还是有点难度的，工作了很多年的老码农也不敢说一定能够理解，因为涉及到面向对象，要能够正确理解接口和抽象类的选择势必要能够理解面向对象，我很早就说了面向对象不是一种技术而是一种思想，是一种编码的方式，大家不要误解面向对象，总这么说显得有点空洞，我将举一个例子来帮助大家理解，这个例子也是我在csdn上看到的，我觉得写的很好，也很有代表性。 <br> \r\n   假设我们在一家车企工作，你在公司的技术部门，公司肯定有销售部门，销售车时肯定是要展示一些参数突出车子的优点的。假设销售部门提出一个需求，要求展示车子的动力参数，于是你屁颠屁颠的开始写代码。你可能写了一个抽象Motor类，如下：\r\n   ![请输入图片描述][1]\r\n \r\n   因为科技还没有很发达，还在使用燃油发动机，于是你写了一个燃油发动机类去继承Motor，然后交付了1.0版本的APP，使用的很流畅，你暗暗自喜，觉得自己的代码优雅的像诗一样。 <br>\r\n   随着时间的推移，科技进步了，出现了光发动机和电发动机，由于电池充电速度是用户很在意的一个参数，而光的强度太弱时光发动机又不能工作，于是返回当前环境的光强也是一个很重要的参数，于是你又分别写了对应的类，同样去继承Motor，加入了获取光强和充电时间的代码，如下： <br>\r\n   ![请输入图片描述][2]\r\n   ![请输入图片描述][3]\r\n \r\n   依然是万事大吉，完美使用无bug。就在这个时候车企造出了光电混合发动机，依然叫你展示车的动力参数，但是这个时候你懵了，光电混合发动机这个类到底应该继承哪个基类呢。 <br>\r\n   很显然光电发动机不能继承Motor，这样做会导致使用instanceOf操作符时得到的结果是该发动机既不属于光发动机也不属于电发动机，但是很显然，现实的情况是光电发动机应该应该同时属于光发动机和电发动机。接着你又想让光电混合发动机继承光发动机和电发动机中的任何一个(因为JAVA不允许使用多重继承，所以只能继承一个)，但是这样做之后在使用instanceOf操作符时得到的结果是光电混合发动机只属于光发动机或者电发动机，这个结果显然也是不够合理的，于是你崩溃了，你不得不重构代码，于是你将代码的继承结构改成了如下结构 <br>\r\n   ![请输入图片描述][4]\r\n \r\n   电发动机\r\n   ![请输入图片描述][5]\r\n \r\n   光发动机\r\n   ![请输入图片描述][6]\r\n \r\n   现在光电混合发动机就很好描述了\r\n   ![请输入图片描述][7]\r\n \r\n   多重实现光发动机接口和电发动机接口就完事了，于是交付软件，这个APP又可以正常跑了，你真是太棒了。<br>\r\n   通过这个例子简易的描述了接口和抽象类到底应该怎么选择，在设计一个类的时候，如果要将该类设计成为基类，则考虑该类中有没有属性或者成员方法，如果没有就设计成一个接口，如果有就设计成一个抽象类，如果实在不清楚如何选择，那么则直接设计成接口。\r\n\r\n\r\n  [1]: https://i.loli.net/2021/05/07/68gtQY1xFZOJ5DS.png\r\n  [2]: https://i.loli.net/2021/05/07/AhmK92Z8f4yEjl3.png\r\n  [3]: https://i.loli.net/2021/05/07/gHSw3klYvzsKoXh.png\r\n  [4]: https://i.loli.net/2021/05/07/ZGyHp1cgFuDwOlx.png\r\n  [5]: https://i.loli.net/2021/05/07/h4RdmWp8FrseSUX.png\r\n  [6]: https://i.loli.net/2021/05/07/z3PfQrMSopcesUO.png\r\n  [7]: https://i.loli.net/2021/05/07/h2Imd7jNFTWGyqJ.png', 1, 'post', 'publish', 'JAVA', 'Java', 193, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (11, '关于锁的底层框架AQS', NULL, 1619701928, 1620537461, '   谈到多线程就不得不说锁，锁是保证多线程并发中保证数据安全的重要工具，当然锁的底层实现也是稍微有些复杂的，关于这方面的知识我也是花了很久时间才弄明白一点，写下这篇文章也算是记录一下心得体会。 <br>\r\n   平时使用锁时可能常用的就是synchronized或者是ReentrantLock，但是锁的底层AQS浑然不知，借助这个机会也一次性弄懂AQS。 AQS全称为AbstractQueuedSynchronizer（真长），这个类是JAVA官方提供的，想实现特定功能的锁只需要继承这个抽象类然后实现相关的方法就可以了，这个类本身并没有具体实现具体怎么锁住代码块的功能，实际上只是维护了一个共享资源变量(volatile int state)和一个FIFO线程等待队列(线程阻塞时会将线程存放到这个等待队列中)。具体访问state的方式有三种 <br>\r\n   1.	getState() <br>\r\n   2.	setState() <br>\r\n   3.	compareAndState() <br>\r\n   AQS定义了两种资源共享方式，Exclusive(独占模式，每次只有一个线程能够访问资源)，Share(共享模式，多个线程都可以访问资源)。<br>\r\n   不同的自定义同步器(锁，后面将用同步器代替锁这种说法，更加书面化)共享资源的方式也不同，自定义同步器在实现时只需要实现共享资源state的获取与释放即可，至于线程等待队列的维护，我在前面就说过了AQS已经完成了这些工作。 <br>\r\n\r\n   •	isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。\r\n\r\n   •	tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。\r\n\r\n   •	tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。\r\n\r\n   •	tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\r\n\r\n   •	tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\r\n\r\n   以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\r\n\r\n   再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。<br>\r\n   一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\r\n\r\n\r\n   前面的基础知识铺垫完了，那么现在对源码进行分析。<br>\r\n   1）	结点状态waitStatus <br>\r\n   这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。<br>\r\n\r\n   •	CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。\r\n\r\n   •	SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。\r\n\r\n   •	CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。\r\n\r\n   •	PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。\r\n\r\n   •	0：新结点入队时的默认状态。\r\n\r\n   注意，负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用>0、<0来判断结点的状态是否正常。\r\n\r\n2）	acquire(int)方法 <br> \r\n   此方法是独占模式下获取共享资源的顶层入口，如果获取到资源线程就直接返回，否则线程进入等待队列，直到获取资源为止，整个过程中忽略中断。下面是acquire(int)的源代码\r\n   ![请输入图片描述][1]\r\n   函数流程如下： <br> \r\n   1.	tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；\r\n\r\n   2.	addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\r\n\r\n   3.	acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\r\n\r\n   4.	如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\r\n\r\n现在看这些方法还有点朦胧，但是不要紧，看完接下来的分析你就会明白了。\r\n\r\n2）方法的源码解读 <br> \r\n   1.tryAcquire(int)方法，源代码如下：\r\n   ![请输入图片描述][2]\r\n   居然只抛出了一个异常，很显然不对劲，但是不要忘记，我在前面就一直说AQS是一个框架，具体的获取和释放资源是由具体的同步器去实现的，其实这里采用的是模版方法设计模式(一种设计模式，有兴趣的朋友可以具体百度了解一下，后续我也会出一些设计模式的记录文章)。当然，这个方法之所以没有设计成abstract，是因为独占模式下只需要实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。很显然，写底层代码的人还是为了我们着想，让开发者尽量减少不必要的的工作。\r\n\r\n2.	addWaiter(Node) <br> \r\n   这个方法用于将当前线程加入到等待队列的队尾，并且返回当前线程所在的节点，源码如下，有注解，应该是看得比较清楚的。\r\n   ![请输入图片描述][3]\r\n   这里补充一下Node这个类，这是AQS中的一个静态内部类，实际上是一个先进先出的队列，用来维护等待线程。\r\n   Enq(Node)方法，不多说了，直接上源代码\r\n   ![请输入图片描述][4]\r\n    懂行的人一眼就看出来这段代码的精华，CAS自旋volatile变量，很经典的用法，如果还不熟悉用法，建议百度一下。\r\n3.	acquireQueued(Node,int) <br> \r\n   通过tryAuquire和addWaiter()方法，该线程已经获取资源失败，被放入等待队列尾部了，下一步要做的就是进入等待状态休息，知道其它线程释放资源后唤醒自己，自己再拿到资源，然后再做想做的事情，是不是和医院拿号有点相似，拿到号之后等待前面的病人问诊完成，轮到自己时再看病，acquireQueued(Node,int)干的就是这件事：在等待队列中排队拿号，直到拿到号了再返回。这个方法非常的关键，上源代码\r\n   ![请输入图片描述][5]\r\n \r\n   先不着急看acquireQueued()的流程,先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。\r\n\r\nshouldParkAfterFailedAcquire(Node, Node) <br> \r\n   这个方法用于检查状态，看看自己是不是真的能够休息了。 \r\n   ![请输入图片描述][6]\r\n   整个流程查询前驱的状态是不是SIGNAL，不是的话就不能安心休息，而是找个安心的休息点，同时试一下看看自己有没有机会拿到号。\r\n\r\nparkAndCheckInterrupt() <br> \r\n   如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\r\n   ![请输入图片描述][7]\r\n \r\n   park会让线程进入wating状态，这个状态有两个途径唤醒，1.unpark() ；2.interrupt()。 <br> \r\n   OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：<br> \r\n   1.	结点进入队尾后，检查状态，找到安全休息点； <br> \r\n   2.	调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己； <br> \r\n   3.	被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。 <br> \r\n\r\n\r\n4.	小结 <br> \r\n   OK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧： <br> \r\n   ![请输入图片描述][8]\r\n \r\n   再来总结下它的流程吧： <br> \r\n   1.	调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回； <br> \r\n   2.	没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式； <br> \r\n   3.	acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 <br> \r\n   4.	如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 <br>\r\n\r\n   至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！ <br>\r\n\r\n\r\n\r\n3）释放资源过程 <br> \r\n   上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：\r\n   ![请输入图片描述][9]\r\n\r\n   逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！\r\n\r\n1.tryRelease(int) <br> \r\n   此方法尝试去释放指定量的资源。下面是tryRelease()的源码：\r\n   ![请输入图片描述][10]\r\n \r\n   跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\r\n\r\n2. unparkSuccessor(Node) <br>\r\n   此方法用于唤醒等待队列中下一个线程。下面是源码： \r\n   ![请输入图片描述][11]\r\n\r\n   这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head && tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！\r\n\r\n最后的小结： <br> \r\n   release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。其实AQS做的就是这些，当前这只是一个简单的概述，还有共享锁没有写出来，篇幅实在是太长了，有兴趣的朋友可以自己去搜索源代码或者博客查看相关信息。这篇博客也参考了另一位博主的文章，链接如下：https://www.cnblogs.com/waterystone/p/4920797.html\r\n\r\n\r\n  [1]: https://i.loli.net/2021/05/07/cysmE6Gg4UA2OH9.png\r\n  [2]: https://i.loli.net/2021/05/07/YH1VypkPFUG7uzf.png\r\n  [3]: https://i.loli.net/2021/05/07/MXyOhoJiYD3GHkn.png\r\n  [4]: https://i.loli.net/2021/05/07/DfJoMvExe1jLwiN.png\r\n  [5]: https://i.loli.net/2021/05/07/sxgNMfwEB8eY5p1.png\r\n  [6]: https://i.loli.net/2021/05/07/LNDAIzGFKmeUplj.png\r\n  [7]: https://i.loli.net/2021/05/07/vehcpKHufw5GdUF.png\r\n  [8]: https://i.loli.net/2021/05/07/vehcpKHufw5GdUF.png\r\n  [9]: https://i.loli.net/2021/05/07/DcISuq5ft7VUvCe.png\r\n  [10]: https://i.loli.net/2021/05/07/bvtgDmpdqEU6uIn.png\r\n  [11]: https://i.loli.net/2021/05/07/gmQI1rOdjbZDVMP.png', 1, 'post', 'publish', 'JAVA', 'Java', 307, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (12, 'HashMap的简单put过程', NULL, 1619702967, 1620536957, '   其实这篇不想写这么早也不想写这个题目，但是明天要去考科目一并且星期天要补5.1假期的课，所以不得不写这一篇，本来是准备写volatile关键字的，不过这一篇也也不差，肯定不会水过去的。\r\n   有些时候我们可能需要一种数据结构来存放数据，下面就是一个个很简单的HashMap的使用方法。\r\n\r\n   ![请输入图片描述][1]\r\n   难道我只讲这么简单的东西吗？那是肯定不会的，我将从hashmap的put方法阐述数据的存放过程，接下来先进行一些基础知识的铺垫。\r\n\r\n1.	Hash\r\n什么是hash，下面是我从百度上摘抄的定义 <br> \r\n   Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。\r\n\r\n   总的来说，hash就是一个计算特征值的函数。这个函数要足够的散列，尽量做到每个数据的hash值都不同。\r\n\r\n2.	HashMap <br> \r\n   HashMap在jdk1.7之前是用数组+链表实现的一种存放数据的数据结构。在jdk1.8之后在数据达到一定的大小会转成数组+链表+红黑树的形式，我不会讲解红黑树扩容机制以及转成红黑树的过程(自己也没弄太懂)，我把我已经了解的部分记录下来。虽然没有扩容机制和树化的讲解，但是我讲的这一部分也足够大家消化理解了。<br>\r\n\r\n\r\n3.	HashMap存放数据的形式 <br> \r\n   HashMap是通过键值对的方式来存放数据的，也就是key=value，例如上面的实例代码，其中的储存结构就是“张三 = 18”。链表的节点的数据包括hash，key，value，以及next，next是当前链表节点的后继。如果计算出两个key的hash(也就是hash碰撞)一模一样，那么就会使用链表将数据存起来。也就是下面的样子 <br> \r\n   ![请输入图片描述][2]\r\n\r\n\r\n基础知识差不多就这些了，知道这些就能够理解我接下来要阐述的代码了。\r\n\r\n------------------------------------------------我是一个分割线---------------------------------\r\n\r\nput()方法\r\n\r\nHashMap是通过put方法来存放数据的，先进入到put方法里面看看\r\n   ![请输入图片描述][3]\r\n\r\nput方法调用了putval这个方法，继续进入到putval方法里面\r\n   ![请输入图片描述][4]\r\n   稍微有一点长，但是我不会全部讲完，这个put方法里面涉及到了树化的代码，我将会略过。\r\n   putval()方法有5个形参，最重要的前三个，也就是hash，key，value，hash是计算出来的hash值，key是要存放数据的钥匙，value就是要存放的数据。传进来的hash在上一个put方法里面就已经计算完成了，先进入到hash方法里面看看，是怎么计算出hash值。\r\n   ![请输入图片描述][5]\r\n   就这么简单，先判断key是否等于空，如果不等于空就用hashCode和经过右移16位hashCode进行异或运算。\r\n   ![请输入图片描述][6]\r\n							(图片来源于网络)\r\n\r\n   计算过程就是上图所示，通过这个函数可以得到一个hash值，然后将这个hash传到putval方法里面。\r\nputVal方法首先进行进行判断\r\n   ![请输入图片描述][7]\r\n   如果数组满了或者数组为空，那么就进行扩容，扩容方法也就是resize，这个方法我就不具体讲了，大家知道有这么回事就行。\r\n\r\n   接着继续进行判断\r\n   ![请输入图片描述][8]\r\n   这里又进行一次运算，计算出存放到数组的具体下标，(n - 1) & hash。\r\n   hash是上一个方法计算好然后传进来的hash，n是整个数组的长度，HashMap规定了数组的长度必须是2的n次方，至于为什么这么做，我或许能够阐述清楚其中一个原因，2的n次方 -  1之后得到的值转成2进制全为1，这样的话可以避免长度影响到hash的值，使hash值只与本身有关。假设数组的长度是16，那么计算的过程就应该如下图所示\r\n   ![请输入图片描述][9]\r\n(图片来源于网络)\r\n\r\n   至此已经完成了所有的计算存放到数组的下标过程，总图来总结一下\r\n   ![请输入图片描述][10]\r\n(图片来源于网络)\r\n\r\n\r\n \r\n   ![请输入图片描述][11]\r\n   如果该下标的位置没有数据，那么直接把数据存进去。如果这一步判断为假，那么就转到else代码块。\r\n   ![请输入图片描述][12]\r\n   一步一步来剖析。\r\n   ![请输入图片描述][13]\r\n   这也是一个判断，意思是如果新节点和旧节点相等的话那么就用一个另外一个新节点来装载旧的节点，这一步是为下一步做准备的。\r\n    ![请输入图片描述][14]\r\n   这里的代码就是树化过程了，具体的我就不多说了，有点复杂，略过。直接进入到下一步。\r\n   ![请输入图片描述][15]\r\n   如果旧节点不等于空，那么用一个变量来存放旧节点的值，接下来的一个判断用来是否覆盖原来旧节点的值，onlyIfAbsent是一个boolean类型的变量，官方的注释是这么描述的\r\n   ![请输入图片描述][16]\r\n\r\n \r\n   如果该值为true，那么则不覆盖旧值。put方法已经为我们传进来flase，所以这边会覆盖掉原来的旧值。afterNodeAccess方法没有具体的用处，是给HashMap的子类LinkedHashMap使用的，子类重写了该方法，但是HashMap类中该方法只是一个空实现，不信看代码 \r\n   ![请输入图片描述][17]\r\n   然后再返回旧节点的值，至此，存放过程总算是完成了。这一个流程看下来，发现底层代码写的真是优雅，只能羡慕了，痛恨自己写不出这样的代码。当然了，能够看懂也是很好的，不过实践中最重要的还是使用，面试的时候可能会让你背一背八股文，那也是没有办法的，还不如早日阅读源码，到时候背起来也能够得心应有一点。其实还有很多东西我没有讲到，比如扩容机制和树化过程，但是鉴于本人的水平以及篇幅，就只阐述这么多了，毕竟要去打球了，我很忙的(此处应有狗头)。\r\n\r\n\r\n  [1]: https://i.loli.net/2021/05/07/KFgCsjyOYGlEAo9.png\r\n  [2]: https://i.loli.net/2021/05/07/K8ymjI631Fq9lVf.png\r\n  [3]: https://i.loli.net/2021/05/07/3jN5UpSuqVWmn9J.png\r\n  [4]: https://i.loli.net/2021/05/07/Fj3nkAdxGeYhvPM.png\r\n  [5]: https://i.loli.net/2021/05/07/Ko3VMquU1RwSBdi.png\r\n  [6]: https://i.loli.net/2021/05/07/dsTL2OhEN4lvfZF.png\r\n  [7]: https://i.loli.net/2021/05/07/ht3TbMdJmrAVjnS.png\r\n  [8]: https://i.loli.net/2021/05/07/zZfvQUOyoXWMbCI.png\r\n  [9]: https://i.loli.net/2021/05/07/MjZtDL8dNQeFzGJ.png\r\n  [10]: https://i.loli.net/2021/05/07/loYrQ4m9kqiz1H8.png\r\n  [11]: https://i.loli.net/2021/05/07/q7ysgI5eYHCNkat.png\r\n  [12]: https://i.loli.net/2021/05/07/Ec9YbAgMfC4O8BS.png\r\n  [13]: https://i.loli.net/2021/05/07/WjnmCgpY8Jiqevl.png\r\n  [14]: https://i.loli.net/2021/05/07/alrPSRei3IWwJCj.png\r\n  [15]: https://i.loli.net/2021/05/07/lVb4Pjptk6Iq3NO.png\r\n  [16]: https://i.loli.net/2021/05/07/YLIKCU3qpZcgRj4.png\r\n  [17]: https://i.loli.net/2021/05/07/symEBleCkr6TPwI.png', 1, 'post', 'publish', 'JAVA', 'Java', 378, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (13, 'volatile关键字', NULL, 1619790880, 1620538702, '上星期因为一些原因没有继续写并发编程的内容，这个星期还是继续写并发编程，关于集合类后续也会继续写，暂时先写并发类，一块一块的来。\r\n\r\n一、	内存模型  <br> \r\n       计算机在执行程序的时候，每一条指令都是由cpu完成的，执行指令的过程中势必会出现对数据的操作，临时数据都存放在主内存中(内存条)。但是这么做存在一个问题，cpu的运算速度很快，相较于从内存中读取数据来说，那是快很多的，如果每执行一次指令都要从内存中读取下一条指令，那么会拖慢cpu的速度，针对这个问题，现在的cpu都内置了高速缓存(打开任务管理器，在性能选项中查看cpu的信息，可以看到cpu的L1-L3缓存信息)。 <br>\r\n       也就是说程序运行的时候并不是读取一条指令条执行一条指令，而是将需要的数据一次性缓存到cpu的高速缓存中，运算完成之后一次性把数据刷新到主内存里，举个简单的例子。例如下面的代码：\r\n\r\n        i = i+1；\r\n\r\n       线程执行这个语句时会从主内存读取i的值，复制一份到高速缓存里，然后cpu执行指令对i进行加1操作，最后将数据写入到高速缓存，再从高速缓存刷新到主内存。\r\n\r\n       这个代码在单线程的情况下是没有任何问题的，但是多线程运行的时候就有问题了。在多核的cpu中，每个线程可能运行在不同的核心里面，假设有两个线程执行这行代码，我们预想的结果是i=2，但事实上很可能不是这样，可能会存在下面的情况：初始的时候两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\r\n\r\n       最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\r\n\r\n       也就是说如果一个变量在多个cpu中都有缓存，那么就可能会出现缓存不一致的问题。\r\n\r\n        \r\n\r\n - 为了解决缓存不一致性问题，通常来说有以下2种解决方法：\r\n\r\n 1. 通过在总线加LOCK#锁的方式\r\n               \r\n 2. 通过缓存一致性协议\r\n\r\n       这2种方式都是硬件层面上提供的方式。\r\n\r\n\r\n       在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\r\n\r\n       但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\r\n\r\n       所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\r\n\r\n![请输入图片描述][1]\r\n \r\n 图片来源于网络\r\n\r\n\r\n\r\n\r\n二、	并发编程中的三个概念 <br> \r\n    并发编程中常会遇见三个问题：原子性问题，可见性问题，有序性问题。先不着急说这三个问题，先弄清楚这三个概念。\r\n\r\n1.	原子性 <br> \r\n　　原子性指的是将一个操作或者多个操作看做一个整体，要么就全部执行，要么就一个都不执行，不会被任何因素打断。一个很经典的例子就是银行账户转账问题。\r\n\r\n       如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\r\n同样反映到并发编程中会出现什么结果呢？<br> \r\n       举个简单的例子，假设为一个32位的变量赋值过程不具备原子性的话可能会出现什么问题。\r\n\r\n        i = 100;\r\n\r\n       若一个线程执行到这个语句，那么会有两个过程，为低16位赋值和高16位赋值，正常的100应该是00000000000000000000000001100100，若一个线程为高16位赋之后被打断了，现在另外一个线程来读取这个数值，那么结果自然是0，因为低16位还没来得及赋值就被打断了，所以你的100块变成了0块，又要去找银行扯皮，但是众所周知银行是老弱势群体了，我们不得不理解他们，结果很可能是你无缘无故少了100。抖个机灵，这就是原子性带来的问题了。\r\n\r\n2.	可见性 <br> \r\n    可见性是指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到这个修改的值，举个简单的例子，看下面的代码：\r\n\r\n        //线程一执行的代码\r\n    \r\n        Int i= 0；\r\n    \r\n        i= 10；\r\n    \r\n        //线程二执行的代码\r\n    \r\n        j= i；\r\n\r\n\r\n       假若执行线程一的是cpu1，执行线程二的是cpu2.由上面的分析可以知道，当线程一执行了i= 10这句话时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br> \r\n       此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。\r\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\r\n\r\n3.	有序性 <br> \r\n       有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面的代码：\r\n\r\n          int i= 0；\r\n\r\n          boolean flag = false；\r\n\r\n          i= 1；\r\n\r\n          flag = true；\r\n\r\n       上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\r\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终        执行结果和代码顺序执行的结果是一致的。<br> \r\n       比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\r\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\r\n\r\n\r\n        int a = 10;    //语句1\r\n\r\n        int r = 2;    //语句2\r\n\r\n        a = a + 3;    //语句3\r\n\r\n        r = a*a;     //语句4\r\n\r\n\r\n       这段代码有四个语句，那么可能的一个执行顺序是语句2->语句1->语句3->语句4，那么有可能是语句2->语句1->语句4->语句3吗？很显然不可能，因为指令重排序不能影响数据之间的依赖性，如果指令2必须用到指令1的结果，那么指令1一定会在指令2之前执行。虽然重排序不影响单个线程的结果，那么多线程呢\r\n\r\n\r\n        //线程1:\r\n\r\n        context = loadContext();   //语句1\r\n\r\n        inited = true;             //语句2\r\n\r\n \r\n        //线程2:\r\n\r\n        while(!inited ){\r\n\r\n          sleep()；\r\n\r\n        }\r\n\r\n        doSomethingwithconfig(context);\r\n\r\n\r\n       上面的代码中由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br> \r\n       从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。<br> \r\n       也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\r\n\r\n三、	Java的内存模型 <br> \r\n       在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。<br> \r\n       在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。<br> \r\n       Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\r\n举个简单的例子：在java中，执行下面这个语句：\r\n\r\n    i = 10;\r\n\r\n       执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。<br> \r\n       那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？\r\n\r\n1.	原子性 <br> \r\n       在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 <br> \r\n       上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子,请分析以下哪些操作是原子性操作：\r\n\r\n            x = 10;         //语句1\r\n            y = x;         //语句2\r\n            x++;           //语句3\r\n            x = x + 1;     //语句4\r\n\r\n       乍一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br> \r\n       语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 <br> \r\n       语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br> \r\n       同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。<br> \r\n       所以上面4个语句只有语句1的操作具备原子性。 <br> \r\n       也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。<br> \r\n       不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。<br> \r\n       从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。<br>\r\n2.	可见性 <br> \r\n       对于可见性，Java提供了volatile关键字来保证可见性。<br> \r\n       当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br> \r\n       而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 <br> \r\n       另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 <br> \r\n\r\n3.	有序性 <br> \r\n       在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 <br>\r\n       在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 <br> \r\n       另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 <br>\r\n       下面就来具体介绍下happens-before原则（先行发生原则）：\r\n\r\n        程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\r\n        锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\r\n        volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\r\n        传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\r\n        线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\r\n        线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\r\n        线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\r\n        对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\r\n\r\n       这8条原则摘自《深入理解Java虚拟机》。 <br>\r\n       这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。<br>\r\n       下面我们来解释一下前4条规则：<br>\r\n       对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>\r\n       第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 <br>\r\n       第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>\r\n       第四条规则实际上就是体现happens-before原则具备传递性。 <br> \r\n\r\n\r\n四、	volatile关键字 <br> \r\n       其实前面说了这么多都是为了讲述volatile关键字做铺垫，既然铺垫完了，那么就可以进入主题了。\r\n\r\n1.	volatile关键字的语义 <br> \r\n        一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： <br> \r\n       1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 <br> \r\n       2）禁止进行指令重排序。 <br> \r\n　　              先看一段代码，假如线程1先执行，线程2后执行：\r\n\r\n                  //线程1\r\n                  boolean stop = false;\r\n                  while(!stop){\r\n 		          doSomething();\r\n                  }\r\n                  //线程2\r\n                  stop = true;\r\n\r\n                这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\r\n　　        下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\r\n　　        那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br> \r\n　　        但是用volatile修饰之后就变得不一样了：<br> \r\n　　        第一：使用volatile关键字会强制将修改的值立即写入主存；<br> \r\n　　        第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br> \r\n　　        第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。<br> \r\n　　        那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取            时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 <br>\r\n　　        那么线程1读取到的就是最新的正确的值。\r\n\r\n2.volatile关键字无法保证原子性 <br> \r\n		看一个例子\r\n		\r\n    public class Test {\r\n        public volatile int inc = 0;\r\n     \r\n        public void increase() {\r\n            inc++;\r\n        }\r\n     \r\n    public static void main(String[] args) {\r\n          final Test test = new Test();\r\n          for(int i=0;i<10;i++){\r\n                new Thread(){\r\n                        public void run() {\r\n                            for(int j=0;j<1000;j++)\r\n                                     test.increase();\r\n                        };\r\n                 }.start();\r\n         }\r\n        \r\n        while(Thread.activeCount()>1)  //保证前面的线程都执行完\r\n        Thread.yield();\r\n        System.out.println(test.inc);\r\n     }\r\n  }\r\n\r\n       大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。<br> \r\n       可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。<br> \r\n       这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。<br> \r\n       在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br> \r\n       假如某个时刻变量inc的值为10; <br> \r\n       线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； <br>\r\n       然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>\r\n       然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。<br> \r\n       那么两个线程分别进行了一次自增操作后，inc只增加了1。<br>\r\n       解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。<br> \r\n       根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。<br>\r\n\r\n\r\n\r\n3.volatile能保证有序性吗？ <br> \r\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 <br>\r\n　　volatile关键字禁止指令重排序有两层意思： <br> \r\n　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br> \r\n　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br> \r\n　　　可能上面说的比较绕，举个简单的例子： <br> \r\n\r\n        //x、y为非volatile变量\r\n        //flag为volatile变量\r\n \r\n        x = 2;        //语句1\r\n        y = 0;        //语句2\r\n        flag = true;  //语句3\r\n        x = 4;         //语句4\r\n        y = -1;       //语句5\r\n\r\n        由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。\r\n        并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。\r\n那么回到前面的一个例子：\r\n\r\n        //线程1:\r\n        context = loadContext();   //语句1\r\n        inited = true;             //语句2\r\n \r\n        //线程2:\r\n        while(!inited ){\r\n            sleep()\r\n        }\r\n        doSomethingwithconfig(context);\r\n\r\n        前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\r\n        这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\r\n\r\n\r\n4.	volatile的原理和实现机制 <br> \r\n前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。 <br> \r\n　　下面这段话摘自《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” <br> \r\n        lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： <br>\r\n       1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>\r\n       2）它会强制将对缓存的修改操作立即写入主存； <br>\r\n       3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 <br>\r\n\r\n\r\n五、	volatile的一个例子 <br>\r\n这边我写了一个单例模式的例子供大家参考，也是单例模式的常用写法：\r\n![请输入图片描述][2]\r\n \r\n\r\n\r\n\r\n最后的总结： <br> \r\n       synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： <br>\r\n　　1）对变量的写操作不依赖于当前值 <br>\r\n　　2）该变量没有包含在具有其他变量的不变式中 <br>\r\n　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 <br>\r\n　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。<br>\r\n\r\n参考博客：https://www.cnblogs.com/dolphin0520/p/3920373.html\r\n\r\n\r\n  [1]: https://i.loli.net/2021/05/07/7fuJsmASqdiELYV.jpg\r\n  [2]: https://i.loli.net/2021/05/07/eOLp5f6iB9TasPw.png', 1, 'post', 'publish', 'java', 'Java', 295, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (14, '单例模式', NULL, 1621239235, 1621318982, '    有时候，我们只希望某个类的实例对象只存在一个，因为创建大量的实例对象势必会导致内存短缺问题，JVM频繁的GC，导致程序的响应速度变慢，这显然不是我们想要的结果，所以我们要想办法，保证对象的唯一性，整个程序中只存在一个对象，大家共用同一个对象，这样对服务器造成的压力会变小，可以获得更加优良的性能，所以出现了单例模式的存在。 <br>\r\n    单例模式应该是23种设计模式中最简单的设计模式之一了，它的目的和作用非常的简单——保证实例对象的唯一性，在很多的著名框架内广泛的存在，例如springboot等框架，对象bean注册到容器中默认都是单例的。单例模式有很多种写法，有几种写法是有缺陷或者被淘汰的，但是抱着学习态度，还是应该每个方法都认识一下。\r\n\r\n## 懒汉式 ##\r\n懒汉式是延迟加载，在需要使用单实例对象时才生成对象，写法也十分的简单，如下。\r\n![请输入图片描述][1]\r\n该写法不是线程安全的，在多线程的情况下会获取到不同的实例对象，完全没有达到单实例对象的作用，一个简单的Test如下。\r\n![请输入图片描述][2]\r\n输出如下，很明显得到了不同的对象\r\n![请输入图片描述][3]\r\n\r\n## 饿汉式 ##\r\n饿汉式如其名，在类加载的时候就生成实例对象，通过一个公共的静态方法对外服务，而构造器私有不允许使用new操作符实例化，写法非常的简单，如下。\r\n![请输入图片描述][4]\r\n好处和坏处都很明显，多线程下也是安全的，但是如果一直没有使用这个对象，那么会造成堆内存的浪费。\r\n\r\n## 双重校验 ##\r\n这种写法使用的是比较多的，通过双重校验来保证实例对象的唯一性，但是会被反射破坏。\r\n![请输入图片描述][5]\r\n    解释一下为什么要双重校验。如果没有双重校验，假设如下一种情况，线程一和线程二进入getInstance方法，同时判断判断lazyMan为空，其中一个线程获取到锁，对象被锁住，另外一个线程被堵塞，获取到锁的线程完成任务之后释放锁，另外一个线程接着进入同步代码块，若没有第二重检验则会直接new一个新的对象，有了双重检验之后进入同步代码块则再检验一次，判断lazyMan不为null，则不会new一个新的对象。\r\n\r\n    并且一定要加volatile关键字，因为new操作不是一个原子性操作，可能会导致一个线程拿到没有完全创建成功的对象，使用时会出现问题，关于这个问题感兴趣的朋友可以百度一下。\r\n\r\n## 静态内部类 ##\r\n这种写法也非常的安全并且没有内存浪费的问题，写法如下。\r\n![请输入图片描述][6]\r\n    因为Java不是一次性将所有的类加载到jvm，而是使用到类时才会加载。所以在没有调用getInstance方法之前内部类是没有被加载的，那么StaticInnerClass对象也就没有存在。同时JVM也帮我们保证了安全性，在类初始化时，其它线程是无法进入的，就算有多个线程同时执行getInstance方法，静态变量赋值只会执行一次，那么自然也只会产生一个实例对象。\r\n\r\n## 枚举 ##\r\n枚举类是在jdk5之后才引入的，所以这种写法不太常见，但却是最简单高校并且安全的一种写法。\r\n![请输入图片描述][7]\r\n    这种写法没有过多的解释，通俗易懂，但是在实际中这种写法确实不是太多，这就是历史遗留问题了，毕竟枚举在jdk5之后才出现。\r\n\r\n  [1]: https://i.loli.net/2021/05/17/jnuOdsZ56MmrRiW.png\r\n  [2]: https://i.loli.net/2021/05/17/xfenOlzcJVCItHR.png\r\n  [3]: https://i.loli.net/2021/05/17/WXMzdtK6fuqlRah.png\r\n  [4]: https://i.loli.net/2021/05/17/kDnZPadNITjUycM.png\r\n  [5]: https://i.loli.net/2021/05/17/iyOujP3asgSv9C7.png\r\n  [6]: https://i.loli.net/2021/05/17/ACNXe5r7yxsGzkM.png\r\n  [7]: https://i.loli.net/2021/05/17/YslR2tMqJQKnUDp.png', 1, 'post', 'publish', 'Java', 'Java', 143, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (15, 'Java中的枚举', NULL, 1622092648, 1622092648, '### 1.为什么需要枚举类 ###\r\n\r\n枚举类是jdk5的新特性，在jdk5之前我们需要定义常量的时候，常常是如下的写法\r\n\r\n    public static final int MONDAY = 0;\r\n    public static final int TUESDAY = 1;\r\n    public static final int WEDNESDAY = 2;\r\n    public static final int THURSDAY = 3;\r\n    //...\r\n\r\n这样做当然是可以实现功能的，但是还是有一些缺点\r\n\r\n - 常量可能会一样\r\n - 不安全，会被反射修改常量的值\r\n - 不够优雅\r\n\r\n为了解决这些问题，java在jdk5的时候引入了枚举类，采用enum关键字我们可以定义枚举类型\r\n\r\n### 2.枚举类型的使用 ###\r\n#### 2.1定义枚举 ####\r\n一个典型的定义格式如下\r\n\r\n    public enum WeekDay{\r\n        // 一个或者多个枚举值的定义，一般使用大写加下划线命名,每个常量之间用逗号分隔，最后用分号结尾，若枚举类中没有方法，分号则可以省略；\r\n        MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;\r\n    }\r\n\r\n#### 2.2定义实例变量，实例代码块，实例方法，构造方法 ####\r\n在枚举中定义自己的构造方法，有参或无参都可以\r\n\r\n    public enum Subject {\r\n    CHINESE(\"王老师\"),\r\n    MATH(\"张老师\"),\r\n    ENGLISH(\"Mr. Yang\");\r\n\r\n    private String teacherName;\r\n    \r\n 	//枚举的构造方法访问权限默认是私有的，因为枚举是常量，各个枚举常量，枚举值的个数在编译期间就定义好了的，在运行时不能被改变\r\n    private Subject(String teacherName) {\r\n        if (teacherName != null && !teacherName.isEmpty())\r\n            this.teacherName = teacherName;\r\n    }\r\n    \r\n    public String getTeacherName() {\r\n        return teacherName;\r\n    }\r\n\r\n    public void setTeacherName(String teacherName) {\r\n        this.teacherName = teacherName;\r\n    }\r\n	//实例代码块\r\n    {\r\n        teacherName = \"未知\";\r\n    }\r\n    }     \r\n\r\n - **枚举类的构造方法一定是私有的!**\r\n\r\n - **若构造方法有参数，则需要为每一个枚举值都提供参数的值**\r\n\r\n - **枚举类中也可以有静态代码块以及静态方法和静态变量，这边就不多做举例，大家可以自行验证**\r\n\r\n - **枚举不能继承或者被继承，但是可以实现接口**\r\n\r\n - **当枚举值被使用到switch语句时，case中不能写枚举类.枚举值，直接写枚举常量即可，否则编译不会通过！**\r\n\r\n - **enum也不可用作数据类型，所有的枚举类都默认继承Enum，所以枚举不是一个新的数据类型，只是一个类**\r\n\r\n - **枚举类中可以声明抽象方法，但是所有的常量都需要实现该方法**\r\n\r\n#### 2.3枚举类中的常用方法 ####\r\n - name()，是一个实例方法，该方法在java.lang.Enum中，返回枚举的名称，枚举的名称就是定义枚举常量时用的字符串，该方法被final修饰，因此不能被重写。\r\n\r\n - values()，是一个静态方法，按照声明的顺序返回枚举类中定义的所有枚举常量组成的数组。这个方法是一个隐含的方法，由编译器生成的。\r\n\r\n - valueOf(String)，是一个静态方法，它根据一个名称返回一个枚举常量，如果名称所表示的枚举常量不存在，则抛出java.lang.IllegalArgumentException异常。这个方法是一个隐含的方法，由编译器生成的，对于一个具体的枚举类来说，这个方法是有的，但是java.lang.Enum中没有这个方法。\r\n\r\n - valueOf(Class,String),是一个静态的方法，存在于java.lang.Enum中，它的作用跟上一个方法类似，只不过第一个参数是Class类型的，需要指定获取那个类型的常量，第二个参数是常量的名称。\r\n\r\n - getDeclaringClass() ，是一个实例方法，存在于java.lang.Enum中，可以获取代表当前枚举类型的Class对象，被final关键字修饰，不能被重写。\r\n\r\n - ordinal()，是一个实例方法，返回当前枚举常量的序号，序号是在枚举类中声明的顺序，从0开始，最大值是java.lang.Integer.MAX_VALUE，被final关键字修饰，不能被重写。\r\n\r\n - toString()，是一个实例方法，来自于java.lang.Object，在java.lang.Enum的实现是直接返回了name属性，就是name()方法的返回值，这个方法可以被重写。\r\n\r\n - compareTo(E) 是一个实例方法，java.lang.Enum类实现了Comparable接口，用于比较当前枚举实例和指定的枚举实例。\r\n\r\n#### 2.4枚举常用的工具库 ####\r\n- EnumSet\r\n这是个抽象类，是枚举专用的Set接口的抽象实现，通过查看其add方法发现，它不允许null值，否则会抛出空指针异常，获取它的对象一般有如下几种静态工厂方法：\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.EnumSet noneOf(Class elementType) ，根据elementType类型创建一个空的Set集合，如果传的Class类型不是枚举，就会抛出类转换异常\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.EnumSet allOf(Class elementType)，根据elementType类型创建一个包含elementType所有枚举常量的Set集合，如果传的Class类型不是枚举，就会抛出类转换异常\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.EnumSet range(E from, E to)，返回一个包含ordinal值从from.ordinal()到to.ordinal()的所有枚举常量的Set集合（包括from和to），如果from.ordinal()大于to.ordinal()，则抛出IllegalArgumentException异常\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.EnumSet complementOf(EnumSet s)，返回的是所有E类型中不包含在s中的枚举常量的Set集合(补集)，s不能为null\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.EnumSet of(E e)，返回一个Set集合包含e，当然这个e不能为null，否则抛出空指针异常，这个方法有5个重载的版本，分别可以传1-5个Enum参数\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.EnumSet of(E first, E… rest) 这是上个方法的可变参数版本\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.EnumSet copyOf(EnumSet s)，创建一个包含s中所有元素的副本，调用clone方法实现的\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.EnumSet copyOf(Collection c)，创建一个包含c中所有枚举实例的Set，c不能为空集合，否则抛出IllegalArgumentException异常\r\n\r\n**除了这些工厂方法之外，还有基本的add，addAll，remove，removeAll，contains，containsAll\r\n，clear，equals等基本方法，就不一一介绍了，值得注意的是，EnumSet的实现类存储Enum对象的方式是采用一个long类型的整数存储的，使用位运算，基本操作在常数时间内完成，效率很高，有兴趣的同学可以去看一下EnumSet的源码。**\r\n\r\n - EnumMap<K extends Enum,V>\r\n这是一个Key类型是枚举的特定Map接口实现，不允许null Key，但允许null值，线程不安全的。获取这个类的对象可以直接使用其构造方法：\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.public EnumMap(Class keyType) keyType显然必须是枚举类类型，返回一个空的Map集合\r\n\r\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.public EnumMap(EnumMap<K, ? extends V> m) 传入一个EnumMap实例，返回一个副本\r\n\r\n其他增删改查的方法跟HashMap基本是一样的，EnumMap把Key和Value都使用数组的方式管理起来，根据Key的ordinal序号，作为Value数组的下表来访问Key对应的值，实现很简洁，效率很高。', 1, 'post', 'publish', 'Java', 'Java', 132, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (16, 'ThreadLocal内存泄漏的问题', NULL, 1622447982, 1622448425, '        最近看到一个特别有意思的问题，关于使用threadlocal可能会导致的内存泄漏问题。ps：内存泄漏指的是还没来得及释放该空间就已经失去了对该空间的控制权，导致这块内存不能及时释放占用内存。长此以往可能会导致服务器宕机。我开始认为java中是不存在内存泄漏问题的，因为jvm的gc垃圾回收实在是做的很出色，但是在网上看博客的时候看到了这个问题，我也还是惊了一下。虽然从来没有遇见过，不过还是记录一下。当然内存泄漏问题也并不是百分之百会发生的，只是可能会发生。\r\n\r\n        在ThreadLocal中有一个静态的内部类，是一个弱引用map，相关的引用概念可以参考如下链接：[四种引用的描述][1]，当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露。最好的做法是使用完之后及时的remove掉value，关于threadlocal的生命周期中存在的引用如下图。\r\n![threadlocal的引用图][2]\r\n\r\n        每个thread中都有一个map，在thread中的变量名是threadlocals，类型是ThreadLocal.ThreadLocalMap，map中的key就是当前的threadlocal，这个key是一个弱引用类型，当把threadlocal置null时就没有任何一个强引用指向threadlocal的实例了，此时进行gc则threadlocal实例对象就会被清除，但是Entry还存在于内存中，因为还存在从CurrenThread过来的一个强引用，value没有清除掉，但是我们已经失去控制了，只有当这个CurrentThread释放时value才会被释放。\r\n\r\n        所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。所以在使用完value之后尽量的及时擦除，以免悲剧事故发生。\r\n\r\n  [1]: https://www.cnblogs.com/liyutian/p/9690974.html\r\n\r\n  [2]: https://i.loli.net/2021/05/31/CyTuDVe1YIM9KFw.png', 1, 'post', 'publish', 'Java', 'Java', 120, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (17, '缓存击穿问题', NULL, 1627734871, 1627735739, '在简书上看到一个关于缓存击穿的问题，叙述的非常简洁明了，感觉十分的好，在此我也记录一下。\r\n\r\n\r\n### 什么是缓存击穿 ###\r\n![请输入图片描述][1]\r\n\r\n    上面的代码，是一个典型的写法：当查询的时候，先从Redis集群中取，如果没有，那么再从DB中查询并设置到Redis集群中。\r\n    注意，在实际开发中，我们一般在缓存中，存储的数据结构是JSON。（JDK提供的序列化方式效率稍微比JSON序列化低一些；而且JDK序列化非常严格，字段的增减，就很可能导致反序列失败，而JSON这方面兼容性较好）\r\n    假设从DB中查询需要2S，那么显然这段时间内过来的请求，在上述的代码下，会全部走DB查询，相当于缓存被直接穿透，这样的现象就称之为“缓存击穿”！\r\n\r\n### 避免缓存击穿 ###\r\n##### 1.加synchronized？ #####\r\n![请输入图片描述][2]\r\n\r\n    如果synchronized加在方法上，使得查询请求都得排队，本来我们的本意是让并发查询走缓存。\r\n    也就是现在synchronized的粒度太大了。\r\n\r\n\r\n##### 2.缩小synchronized的粒度? #####\r\n![请输入图片描述][3]\r\n\r\n    上面代码，在缓存有数据时，让查询缓存的请求不必排队，减小了同步的粒度。但是，仍然没有解决缓存击穿的问题。\r\n    虽然，多个查询DB的请求进行排队，但是即便一个DB查询请求完成并设置到缓存中，其他查询DB的请求依然会继续查询DB！\r\n\r\n##### 3.synchronized+双重检查机制 #####\r\n![请输入图片描述][4]\r\n\r\n     通过synchronized+双重检查机制：\r\n     在同步块中，继续判断检查，保证不存在，才去查DB。\r\n\r\n### 代码抽象 ###\r\n    发现没有，其实我们处理缓存的代码，除了具体的查询DB逻辑外，其他都是模板化的。下面我们就来抽象下！\r\n\r\n#### 一个查询DB的接口： ####\r\n![请输入图片描述][5]\r\n\r\n    既然查询具体的DB是由业务来决定的，那么暴露这个接口让业务去实现它。\r\n\r\n#### 一个模板： ####\r\n![请输入图片描述][6]\r\n\r\n    Spring不是有很多Template类么？\r\n    我们也可以通过这种思想对代码进行一个抽象，让外界来决定具体的业务实现，而把模板步骤写好。（有点类似AOP的概念）\r\n\r\n#### 改进后的代码： ####\r\n![请输入图片描述][7]\r\n\r\n    从这里可以看出，我们并不关心缓存的数据从哪里加载，而是交给具体的使用方。\r\n    而且使用方在使用时再也不必关注缓存击穿的问题，因为我们都给抽象了。\r\n\r\n    此文章转载于https://www.jianshu.com/p/93767dac6b56\r\n\r\n\r\n  [1]: https://i.loli.net/2021/07/31/wsvEbhZuiPelM1a.png\r\n  [2]: https://i.loli.net/2021/07/31/Ukp8QbfIVRn2Di1.png\r\n  [3]: https://i.loli.net/2021/07/31/XDUsLAdkMrniJPF.png\r\n  [4]: https://i.loli.net/2021/07/31/39l5wzbtfjKTve6.png\r\n  [5]: https://i.loli.net/2021/07/31/Ye4KW5r2PqpTHd9.png\r\n  [6]: https://i.loli.net/2021/07/31/HJDkP8yu4GA7zSo.png\r\n  [7]: https://i.loli.net/2021/07/31/c43jGHDYqUouW5V.png', 1, 'post', 'publish', 'java,redis', 'Java', 127, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (18, '双亲委派机制', NULL, 1629114128, 1629114128, '`以前总是看到双亲委派机制这个名词，但是没有去深究，当时jvm的知识也看得少，最近又看到这个词汇，终于是下定决心弄清楚双亲委派机制的作用`\r\n### 双亲委派机制####\r\n    首先做一个小测试，猜想一下下面的代码会报什么错\r\n    package java.lang;\r\n    public class String {\r\n        public static void main(String[] args) {\r\n            System.out.println(1);\r\n        }    \r\n    }\r\n\r\n    这一小段代码会报一段很离谱的错误，一般人估计是想不到的，我直接贴报错信息\r\n    错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:\r\n       public static void main(String[] args)\r\n    否则 JavaFX 应用程序类必须扩展javafx.application.Application\r\n\r\n#### 这是为什么呢？####\r\n    这就不得不说都双亲委派机制了，首先我们知道类的加载都是通过ClassLoder(类加载器)加载的\r\n    JVM中提供了三层的ClassLoader：\r\n        1.Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。\r\n        2.ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。\r\n        3.AppClassLoader：主要负责加载应用程序的主函数类\r\n    \r\n   这三层加载器都继承自ClassLoder，拥有classLoder()这个方法(这个方法里有参数，但是我们现在讨论的问题不关心这个，在此略过)。\r\n   贴上源码看看这个方法\r\n        \r\n        protected Class<?> loadClass(String name, boolean resolve)\r\n            throws ClassNotFoundException\r\n        {\r\n            synchronized (getClassLoadingLock(name)) {\r\n                //先检查，是否加载过这个类\r\n                Class<?> c = findLoadedClass(name);\r\n                //如果没有加载过，就执行下面代码\r\n                if (c == null) {\r\n                    long t0 = System.nanoTime();\r\n                    try {\r\n                        //如果该加载器有父类，则交给父类加载\r\n                        if (parent != null) {\r\n                            c = parent.loadClass(name, false);      \r\n                        } else {\r\n                            //已经是根加载器，则由根加载器加载类\r\n                            c = findBootstrapClassOrNull(name);\r\n                        }\r\n                    } catch (ClassNotFoundException e) {\r\n                        // ClassNotFoundException thrown if class not found\r\n                        // from the non-null parent class loader\r\n                    }\r\n\r\n                    if (c == null) {\r\n                        //根加载器没有加载类则由子类加载器尝试加载\r\n                        long t1 = System.nanoTime();\r\n                        c = findClass(name);\r\n\r\n                        // this is the defining class loader; record the stats\r\n                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\r\n                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\r\n                        sun.misc.PerfCounter.getFindClasses().increment();\r\n                    }\r\n                }\r\n                if (resolve) {\r\n                    resolveClass(c);\r\n                }\r\n                return c;\r\n            }\r\n        }\r\n\r\n    我想，通过上面的代码以及我给出来的注释，双亲委派机制已经很明朗了。\r\n    从AppClassLoader加载器层层往上传递类的加载任务，父类加载器没有加载到才让给子类加载器完成加载任务。\r\n    那么这里大家也应该明白了我们自己写的代码会报错没有main方法,AppClassLoader接收到任务向上传递，根加载器在核心类库中加载到了jdk自己的String类，但是jdk自己的String类里面没有main方法，所以报了一个没有main方法的错误。\r\n    这个机制保证了一定的安全性，避免了核心类库被随意篡改。\r\n    我再贴一张图，帮助更好的理解双亲委派机制。\r\n![请输入图片描述][1]\r\n    \r\n\r\n\r\n  [1]: https://i.loli.net/2021/08/16/s4hqbkaQyDuIj7J.png', 1, 'post', 'publish', 'java,jvm', 'Java', 26, 0, 1, 1, 1);

-- ----------------------------
-- Table structure for t_logs
-- ----------------------------
DROP TABLE IF EXISTS `t_logs`;
CREATE TABLE `t_logs`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `action` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `author_id` int(10) NULL DEFAULT NULL,
  `ip` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `created` int(10) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 86 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_logs
-- ----------------------------
INSERT INTO `t_logs` VALUES (1, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815277);
INSERT INTO `t_logs` VALUES (2, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815280);
INSERT INTO `t_logs` VALUES (3, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815318);
INSERT INTO `t_logs` VALUES (4, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815398);
INSERT INTO `t_logs` VALUES (5, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815482);
INSERT INTO `t_logs` VALUES (6, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815492);
INSERT INTO `t_logs` VALUES (7, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1496815955);
INSERT INTO `t_logs` VALUES (8, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1496815964);
INSERT INTO `t_logs` VALUES (9, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496989015);
INSERT INTO `t_logs` VALUES (10, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496989366);
INSERT INTO `t_logs` VALUES (11, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497317863);
INSERT INTO `t_logs` VALUES (12, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/zhisheng17\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1497318696);
INSERT INTO `t_logs` VALUES (13, '修改个人信息', '{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}', 1, '0:0:0:0:0:0:0:1', 1497319220);
INSERT INTO `t_logs` VALUES (14, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497319856);
INSERT INTO `t_logs` VALUES (15, '登录后台', NULL, 1, '127.0.0.1', 1497321561);
INSERT INTO `t_logs` VALUES (16, '登录后台', NULL, 1, '127.0.0.1', 1497322738);
INSERT INTO `t_logs` VALUES (17, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497323446);
INSERT INTO `t_logs` VALUES (18, '删除文章', '2', 1, '0:0:0:0:0:0:0:1', 1497323495);
INSERT INTO `t_logs` VALUES (19, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497427641);
INSERT INTO `t_logs` VALUES (20, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497428250);
INSERT INTO `t_logs` VALUES (21, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497428290);
INSERT INTO `t_logs` VALUES (22, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497428556);
INSERT INTO `t_logs` VALUES (23, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497674581);
INSERT INTO `t_logs` VALUES (24, '修改个人信息', '{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}', 1, '0:0:0:0:0:0:0:1', 1497674690);
INSERT INTO `t_logs` VALUES (25, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497676623);
INSERT INTO `t_logs` VALUES (26, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497683817);
INSERT INTO `t_logs` VALUES (27, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497685128);
INSERT INTO `t_logs` VALUES (28, '登录后台', NULL, 1, '127.0.0.1', 1497689032);
INSERT INTO `t_logs` VALUES (29, '登录后台', NULL, 1, '183.95.51.243', 1619682392);
INSERT INTO `t_logs` VALUES (30, '删除文章', '/upload/2017/06/t93vgdj6o8irgo87ds56u0ou0s.jpeg', 1, '183.95.51.243', 1619682398);
INSERT INTO `t_logs` VALUES (31, '登录后台', NULL, 1, '183.95.51.243', 1619682502);
INSERT INTO `t_logs` VALUES (32, '保存系统设置', '{\"social_zhihu\":\"\",\"social_github\":\"https://github.com/zz201507\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '183.95.51.243', 1619682528);
INSERT INTO `t_logs` VALUES (33, '删除文章', '6', 1, '183.95.51.243', 1619682653);
INSERT INTO `t_logs` VALUES (34, '删除文章', '5', 1, '183.95.51.243', 1619682662);
INSERT INTO `t_logs` VALUES (35, '登录后台', NULL, 1, '183.95.51.243', 1619686516);
INSERT INTO `t_logs` VALUES (36, '登录后台', NULL, 1, '183.95.51.27', 1619700184);
INSERT INTO `t_logs` VALUES (37, '登录后台', NULL, 1, '183.95.51.27', 1619703039);
INSERT INTO `t_logs` VALUES (38, '登录后台', NULL, 1, '183.95.51.27', 1619703343);
INSERT INTO `t_logs` VALUES (39, '登录后台', NULL, 1, '183.95.51.27', 1619703367);
INSERT INTO `t_logs` VALUES (40, '登录后台', NULL, 1, '183.95.51.27', 1619704073);
INSERT INTO `t_logs` VALUES (41, '登录后台', NULL, 1, '183.95.51.27', 1619704122);
INSERT INTO `t_logs` VALUES (42, '修改密码', NULL, 1, '183.95.51.27', 1619704148);
INSERT INTO `t_logs` VALUES (43, '登录后台', NULL, 1, '61.242.135.47', 1619713286);
INSERT INTO `t_logs` VALUES (44, '登录后台', NULL, 1, '183.95.51.216', 1619790723);
INSERT INTO `t_logs` VALUES (45, '登录后台', NULL, 1, '183.95.51.216', 1619792505);
INSERT INTO `t_logs` VALUES (46, '登录后台', NULL, 1, '183.95.51.216', 1619792552);
INSERT INTO `t_logs` VALUES (47, '登录后台', NULL, 1, '183.95.49.184', 1619892057);
INSERT INTO `t_logs` VALUES (48, '登录后台', NULL, 1, '183.95.50.229', 1620274984);
INSERT INTO `t_logs` VALUES (49, '登录后台', NULL, 1, '183.95.50.229', 1620276198);
INSERT INTO `t_logs` VALUES (50, '登录后台', NULL, 1, '183.95.50.211', 1620276275);
INSERT INTO `t_logs` VALUES (51, '登录后台', NULL, 1, '61.242.130.28', 1620280923);
INSERT INTO `t_logs` VALUES (52, '登录后台', NULL, 1, '61.242.135.15', 1620350098);
INSERT INTO `t_logs` VALUES (53, '登录后台', NULL, 1, '61.242.135.15', 1620355080);
INSERT INTO `t_logs` VALUES (54, '登录后台', NULL, 1, '183.95.51.239', 1620359818);
INSERT INTO `t_logs` VALUES (55, '登录后台', NULL, 1, '61.242.135.15', 1620372923);
INSERT INTO `t_logs` VALUES (56, '登录后台', NULL, 1, '183.95.51.251', 1620475494);
INSERT INTO `t_logs` VALUES (57, '登录后台', NULL, 1, '183.95.51.251', 1620478715);
INSERT INTO `t_logs` VALUES (58, '修改个人信息', '{\"uid\":1,\"email\":\"zhangzhe201507@foxmail.com\",\"screenName\":\"cheungZ\"}', 1, '183.95.51.251', 1620479110);
INSERT INTO `t_logs` VALUES (59, '登录后台', NULL, 1, '61.242.129.245', 1620522974);
INSERT INTO `t_logs` VALUES (60, '登录后台', NULL, 1, '183.95.51.19', 1620535449);
INSERT INTO `t_logs` VALUES (61, '登录后台', NULL, 1, '119.36.214.175', 1620722362);
INSERT INTO `t_logs` VALUES (62, '登录后台', NULL, 1, '119.36.214.175', 1620722618);
INSERT INTO `t_logs` VALUES (63, '登录后台', NULL, 1, '61.242.130.46', 1621205956);
INSERT INTO `t_logs` VALUES (64, '登录后台', NULL, 1, '119.36.214.174', 1621238113);
INSERT INTO `t_logs` VALUES (65, '删除文章', '/upload/2021/05/4uu9u3lnbmg7krtrg0rkvbi1o3.jpg', 1, '119.36.214.174', 1621239395);
INSERT INTO `t_logs` VALUES (66, '登录后台', NULL, 1, '183.95.51.115', 1621250884);
INSERT INTO `t_logs` VALUES (67, '登录后台', NULL, 1, '183.95.51.235', 1621318959);
INSERT INTO `t_logs` VALUES (68, '登录后台', NULL, 1, '183.95.50.55', 1621424657);
INSERT INTO `t_logs` VALUES (69, '登录后台', NULL, 1, '223.104.20.78', 1621606904);
INSERT INTO `t_logs` VALUES (70, '登录后台', NULL, 1, '119.36.214.174', 1621845751);
INSERT INTO `t_logs` VALUES (71, '登录后台', NULL, 1, '119.36.214.179', 1621927538);
INSERT INTO `t_logs` VALUES (72, '登录后台', NULL, 1, '119.36.214.173', 1622014295);
INSERT INTO `t_logs` VALUES (73, '登录后台', NULL, 1, '183.95.50.108', 1622090433);
INSERT INTO `t_logs` VALUES (74, '登录后台', NULL, 1, '183.95.50.108', 1622092622);
INSERT INTO `t_logs` VALUES (75, '登录后台', NULL, 1, '183.95.51.205', 1622385057);
INSERT INTO `t_logs` VALUES (76, '登录后台', NULL, 1, '119.36.214.176', 1622445627);
INSERT INTO `t_logs` VALUES (77, '登录后台', NULL, 1, '119.36.214.176', 1622448383);
INSERT INTO `t_logs` VALUES (78, '登录后台', NULL, 1, '119.36.214.179', 1622536702);
INSERT INTO `t_logs` VALUES (79, '登录后台', NULL, 1, '27.26.132.38', 1627732928);
INSERT INTO `t_logs` VALUES (80, '登录后台', NULL, 1, '27.26.128.30', 1629112273);
INSERT INTO `t_logs` VALUES (81, '登录后台', NULL, 1, '27.20.243.175', 1629905858);
INSERT INTO `t_logs` VALUES (82, '登录后台', NULL, 1, '27.20.243.175', 1629907955);
INSERT INTO `t_logs` VALUES (83, '登录后台', NULL, 1, '27.20.243.175', 1629908283);
INSERT INTO `t_logs` VALUES (84, '登录后台', NULL, 1, '27.20.243.175', 1630139839);
INSERT INTO `t_logs` VALUES (85, '登录后台', NULL, 1, '27.20.243.175', 1630140050);

-- ----------------------------
-- Table structure for t_metas
-- ----------------------------
DROP TABLE IF EXISTS `t_metas`;
CREATE TABLE `t_metas`  (
  `mid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `slug` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `description` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `sort` int(10) UNSIGNED NULL DEFAULT 0,
  `parent` int(10) UNSIGNED NULL DEFAULT 0,
  PRIMARY KEY (`mid`) USING BTREE,
  INDEX `slug`(`slug`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 27 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_metas
-- ----------------------------
INSERT INTO `t_metas` VALUES (1, 'default', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (8, '随笔', '随笔', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (9, 'Java', 'Java', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (10, 'Java', 'Java', 'category', '有关Java的博客', 0, 0);
INSERT INTO `t_metas` VALUES (11, 'HashMap', 'HashMap', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (12, 'HashTable', 'HashTable', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (13, 'HashSet', 'HashSet', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (14, 'ConcurrentHashMap', 'ConcurrentHashMap', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (22, 'myGitHub', 'https://github.com/zz201507', 'link', '', 1, 0);
INSERT INTO `t_metas` VALUES (23, '薄荷图床', 'https://riyugo.com/', 'link', '', 0, 0);
INSERT INTO `t_metas` VALUES (24, 'sm图床', 'https://sm.ms/', 'link', '', 0, 0);
INSERT INTO `t_metas` VALUES (25, 'redis', 'redis', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (26, 'jvm', 'jvm', 'tag', NULL, 0, 0);

-- ----------------------------
-- Table structure for t_options
-- ----------------------------
DROP TABLE IF EXISTS `t_options`;
CREATE TABLE `t_options`  (
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `value` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `description` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_options
-- ----------------------------
INSERT INTO `t_options` VALUES ('allow_install', '', '');
INSERT INTO `t_options` VALUES ('site_description', 'SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统', NULL);
INSERT INTO `t_options` VALUES ('site_keywords', 'Blog', NULL);
INSERT INTO `t_options` VALUES ('site_theme', 'default', NULL);
INSERT INTO `t_options` VALUES ('site_title', 'Blog', '');
INSERT INTO `t_options` VALUES ('social_github', 'https://github.com/zz201507', NULL);
INSERT INTO `t_options` VALUES ('social_twitter', '', NULL);
INSERT INTO `t_options` VALUES ('social_weibo', '', NULL);
INSERT INTO `t_options` VALUES ('social_zhihu', '', NULL);

-- ----------------------------
-- Table structure for t_relationships
-- ----------------------------
DROP TABLE IF EXISTS `t_relationships`;
CREATE TABLE `t_relationships`  (
  `cid` int(10) UNSIGNED NOT NULL,
  `mid` int(10) UNSIGNED NOT NULL,
  PRIMARY KEY (`cid`, `mid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_relationships
-- ----------------------------
INSERT INTO `t_relationships` VALUES (3, 9);
INSERT INTO `t_relationships` VALUES (3, 10);
INSERT INTO `t_relationships` VALUES (4, 9);
INSERT INTO `t_relationships` VALUES (4, 10);
INSERT INTO `t_relationships` VALUES (4, 11);
INSERT INTO `t_relationships` VALUES (4, 12);
INSERT INTO `t_relationships` VALUES (4, 13);
INSERT INTO `t_relationships` VALUES (4, 14);
INSERT INTO `t_relationships` VALUES (7, 9);
INSERT INTO `t_relationships` VALUES (7, 10);
INSERT INTO `t_relationships` VALUES (8, 9);
INSERT INTO `t_relationships` VALUES (8, 10);
INSERT INTO `t_relationships` VALUES (9, 9);
INSERT INTO `t_relationships` VALUES (9, 10);
INSERT INTO `t_relationships` VALUES (10, 9);
INSERT INTO `t_relationships` VALUES (10, 10);
INSERT INTO `t_relationships` VALUES (11, 9);
INSERT INTO `t_relationships` VALUES (11, 10);
INSERT INTO `t_relationships` VALUES (12, 9);
INSERT INTO `t_relationships` VALUES (12, 10);
INSERT INTO `t_relationships` VALUES (13, 9);
INSERT INTO `t_relationships` VALUES (13, 10);
INSERT INTO `t_relationships` VALUES (14, 9);
INSERT INTO `t_relationships` VALUES (14, 10);
INSERT INTO `t_relationships` VALUES (15, 9);
INSERT INTO `t_relationships` VALUES (15, 10);
INSERT INTO `t_relationships` VALUES (16, 9);
INSERT INTO `t_relationships` VALUES (16, 10);
INSERT INTO `t_relationships` VALUES (17, 9);
INSERT INTO `t_relationships` VALUES (17, 10);
INSERT INTO `t_relationships` VALUES (17, 25);
INSERT INTO `t_relationships` VALUES (18, 9);
INSERT INTO `t_relationships` VALUES (18, 10);
INSERT INTO `t_relationships` VALUES (18, 26);

-- ----------------------------
-- Table structure for t_users
-- ----------------------------
DROP TABLE IF EXISTS `t_users`;
CREATE TABLE `t_users`  (
  `uid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `home_url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `screen_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `created` int(10) UNSIGNED NULL DEFAULT 0,
  `activated` int(10) UNSIGNED NULL DEFAULT 0,
  `logged` int(10) UNSIGNED NULL DEFAULT 0,
  `group_name` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 'visitor',
  PRIMARY KEY (`uid`) USING BTREE,
  UNIQUE INDEX `name`(`username`) USING BTREE,
  UNIQUE INDEX `mail`(`email`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_users
-- ----------------------------
INSERT INTO `t_users` VALUES (1, 'admin', 'd2442cf3574882a26c6cb4f86b245542', 'zhangzhe201507@foxmail.com', NULL, 'cheungZ', 1490756162, 0, 0, 'visitor');

SET FOREIGN_KEY_CHECKS = 1;
